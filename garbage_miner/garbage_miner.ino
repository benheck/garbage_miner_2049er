//Garbage Miner 2049 (2018-2021) Ben Heck

#include <Arduboy2Core.h>
#include <EEPROM.h>

Arduboy2Core a;

#define menu 			0		//Game states
#define game 			1
#define edit 			2
#define storyTime		3
#define levelStart		4
#define gameOver		5
#define levelStartRogue	6

#define empty 			0				//Object values (lower nibble of map bytes)
#define dirt1 			1
#define man   			2
#define door			3
#define wall  			4
#define ball  			5
#define gas				6				//Turn to flammable gas?
#define jar  			7
#define seeker			8
#define jem				9
#define slime 			10
#define monster 		11
#define crawler 		12
#define isExploding		12
#define exp1  			13
#define exp2  			14
#define exp3  			15

#define moveUp    		0x00			//Object attributes (upper nibble of map bytes)
#define moveDown  		0x10
#define moveLeft  		0x20
#define moveRight 		0x30
#define dontMove  		0x80				//Change to 0x40?
#define falling	  		0x80

#define upBit			0x80		//Bitwise defines for one-shot button presses
#define downBit			0x40
#define leftBit			0x20
#define rightBit 		0x10
#define aBit			0x08
#define bBit			0x04

#define pushPower 		5				//How many reps to push a boulder

uint8_t level;						//Which game level we are on
uint8_t lives;						//How many men are left
uint32_t score;						//Player score

//Level pointer offset:    1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  xx  	
uint16_t levelSize[] = {0, 527, 510, 621, 550, 309, 606, 529, 465, 65535};	//Relative offset pointers to start of flash memory for all levels (use level-1 for this because of zero offset) 65535 = end of level data

const uint8_t levelData[] PROGMEM = {    //The built-in levels data

//Level 1: (Rock intro) - DONE
0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x95, 0x3, 0x5A, 0x3, 0x51, 0x41, 0x6, 0x93, 0x41, 0x14, 0x7, 0x51, 0x1, 0x96, 0x1, 0x11, 0x5A, 0x43, 0x51, 0x41, 0x19, 0x41, 0x13, 0x52, 0x5, 0x11, 0x51, 0x91, 0x49, 0x59, 0x43, 0x51, 0x41, 0x19, 0x41, 0x13, 0x53, 0x2, 0x31, 0x1, 0x11, 0x52, 0x8, 0x41, 0x11, 0x57, 0x44, 0x51, 0x41, 0x12, 0x51, 0x16, 0x41, 0x13, 0x54, 0x3, 0x11, 0x42, 0x8, 0x44, 0x53, 0x43, 0x13, 0x51, 0x41, 0x12, 0x51, 0x13, 0x1, 0x12, 0x41, 0x13, 0x58, 0x41, 0x51, 0x2, 0x14, 0x51, 0x5, 0x11, 0x43, 0x16, 0x41, 0x14, 0x51, 0x11, 0x2, 0x11, 0x42, 0x14, 0x55, 0x11, 0x41, 0x11, 0x2, 0x13, 0x53, 0x44, 0x1, 0x41, 0x16, 0x51, 0x11, 0x41, 0x14, 0x51, 0x11, 0x3, 0x51, 0x3, 0x12, 0x54, 0x12, 0x41, 0x11, 0x5, 0x53, 0x3, 0x41, 0x1, 0x41, 0x14, 0x51, 0x11, 0x51, 0x11, 0x41, 0x12, 
0x51, 0x13, 0x2, 0x11, 0x42, 0x2, 0x15, 0x51, 0x12, 0x41, 0x11, 0x47, 0x51, 0x12, 0x1, 0x41, 0x4, 0x12, 0x51, 0x11, 0x51, 0x11, 0x41, 0x12, 0x51, 0x13, 0x1, 0x12, 0x41, 0x7, 0x13, 0x42, 0x11, 0x7, 0x51, 0x3, 0x41, 0x4, 0x16, 0x41, 0x12, 0x44, 0x51, 0x43, 0x1, 0x51, 0x8, 0x41, 0x2, 0x17, 0x41, 0x1, 0x43, 0x9, 0x11, 0x41, 0x19, 0x41, 0x1, 0x11, 0x8, 0x42, 0x1, 0x17, 0x41, 0x1, 0x92, 0x41, 0x5, 0x91, 0x3, 0x11, 0x41, 0x12, 0x46, 0x11, 0x41, 0xB, 0x41, 0x1, 0x51, 0x94, 0x51, 0x11, 0x41, 0x1, 0x12, 0x41, 0x5, 0x15, 0x41, 0x12, 0x41, 0x16, 0x41, 0xB, 0x41, 0x11, 0x52, 0x92, 0x51, 0x12, 0x41, 0x1, 0x12, 0x41, 0x9, 0x11, 0x44, 0x11, 0x4F, 0x43, 0x11, 0x54, 0x13, 0x41, 0x1, 0x12, 0x41, 0x6, 0x91, 0x2, 0x16, 0x41, 0x1F, 0x13, 0x42, 0x51, 
0x4F, 0x4A, 0x94, 0x4D, 0x1, 0x17, 0x43, 0x1D, 0x52, 0x11, 0x42, 0x94, 0x41, 0x11, 0x91, 0x2, 0x51, 0x3, 0x13, 0x42, 0x4, 0x14, 0x51, 0x13, 0x51, 0x13, 0x52, 0x13, 0x91, 0x11, 0x52, 0x11, 0x42, 0x54, 0x41, 0x12, 0x1, 0x11, 0x41, 0x4, 0x13, 0x51, 0x6, 0x12, 0x51, 0x12, 0x52, 0x11, 0x91, 0x12, 0x51, 0x1F, 0x12, 0x2, 0x41, 0x5, 0x12, 0x51, 0x6, 0x12, 0x51, 0x13, 0x51, 0x14, 0x51, 0x12, 0x52, 0x16, 0x4, 0x13, 0x1, 0x52, 0x5, 0x91, 0x11, 0x51, 0x2, 0x91, 0x3, 0x12, 0x51, 0x11, 0x91, 0x1A, 0x52, 0x15, 0x4, 0x13, 0x1, 0x11, 0x41, 0x17, 0x51, 0x4F, 0x4F, 0x4A, 0x51, 0x14, 0x52, 0x17, 0x4, 0x51, 0x2, 0x91, 0x1, 0x12, 0x41, 0x92, 0x13, 0x59, 0x41, 0x91, 0x51, 0x12, 0x41, 0x53, 0x91, 0x52, 0x12, 0x2, 0x91, 0x12, 0x91, 0x14, 0x41, 0x2, 0x14, 0x41, 
0x92, 0x1A, 0x52, 0x41, 0x91, 0x51, 0x12, 0x41, 0x53, 0x11, 0x52, 0x11, 0x54, 0x1, 0x15, 0x51, 0x41, 0x51, 0x3, 0x12, 0x41, 0x92, 0x17, 0x1, 0x13, 0x51, 0x41, 0x91, 0x51, 0x12, 0x41, 0x53, 0x11, 0x58, 0x14, 0x52, 0x41, 0x52, 0x2, 0x11, 0x51, 0x41, 0x92, 0x16, 0x41, 0x2, 0x11, 0x1, 0x51, 0x41, 0x91, 0x13, 0x41, 0x53, 0x11, 0x52, 0x45, 0x51, 0x47, 0x14, 0x92, 0x18, 0x51, 0x41, 0x3, 0x12, 0x1, 0x11, 0x1, 0x12, 0x41, 0x51, 0x11, 0x51, 0x11, 0x51, 0x11, 0x3, 0x15, 0x4, 0x41, 0x16, 0x41, 0x2, 0x15, 0x51, 0x41, 0x4, 0x51, 0x41, 0x3, 0x11, 0x41, 0x11, 0x1, 0x51, 0x11, 0x51, 0x2, 0x21, 0x6, 0x14, 0x41, 0x15, 0x51, 0x41, 0x3, 0x14, 0x51, 0x41, 0x3, 0x52, 0x41, 0x4, 0x11, 0x91, 0x1, 0x11, 0x1, 0x11, 0xD, 0x41, 0x14, 0x52, 0x41, 0x4, 0x12, 0x52, 
0x41, 0x2, 0x53, 0x41, 0x5, 0x11, 0x5, 
//Data pointer:527

//Level 2 data: (Wall Huggers 1) - DONE
0x32, 0x0, 0xFA, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x12, 0x51, 0x13, 0x51, 0x12, 0x9, 0x41, 0x11, 0x41, 0x1, 0x51, 0x4, 0x41, 0x2, 0x51, 0x13, 0x3, 0x51, 0xC1, 0x7, 0x19, 0x1, 0x17, 0x1, 0x41, 0x11, 0x51, 0x1, 0x15, 0x51, 0x1, 0x15, 0x1, 0x43, 0x8, 0x12, 0x1, 0x13, 0x1, 0x12, 0xC1, 0x13, 0x3, 0x11, 0x1, 0x41, 0x11, 0x41, 0x3, 0x51, 0x12, 0x41, 0x1, 0x14, 0x51, 0x1, 0x41, 0x11, 0x8, 0xC1, 0x12, 0x1, 0x13, 0x1, 0x12, 0x51, 0x2, 0x11, 0x3, 0x12, 0x41, 0x11, 0x51, 0x1, 0x15, 0x51, 0x1, 0x15, 0x1, 0x41, 0x1C, 0x6, 0x12, 0x2, 0x11, 0x5, 0x41, 0x11, 0x41, 0x1, 0x15, 0x41, 0xC1, 0x14, 0x51, 0x1, 0x41, 0x18, 0x51, 0x1A, 0x1, 0x13, 0x4, 0xC1, 0x41, 0x11, 0x51, 0x2, 0xC1, 0x51, 0x13, 0x51, 0x15, 0xC1, 0x41, 0x14, 0x51, 0x11, 0x51, 0x16, 0x3, 0x13, 0x1, 0x13, 0x1, 0x13, 0x51, 0x41, 
0x11, 0x41, 0x16, 0x42, 0x16, 0x41, 0x18, 0x1, 0x11, 0x51, 0x12, 0x3, 0x13, 0x1, 0x13, 0x1, 0x12, 0x52, 0x41, 0x11, 0x4F, 0x41, 0x14, 0x1, 0x11, 0x1, 0x11, 0x1, 0x15, 0x1, 0x14, 0x1, 0x13, 0x1, 0x11, 0x53, 0x41, 0x11, 0x41, 0x52, 0x11, 0x51, 0x11, 0x51, 0x11, 0x51, 0x15, 0x51, 0x41, 0x14, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0xC1, 0x51, 0x2, 0x51, 0x1, 0x12, 0x4, 0x51, 0x11, 0x53, 0x41, 0x11, 0x41, 0x52, 0x1B, 0x51, 0x41, 0x14, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x1, 0x12, 0x1, 0x11, 0x1, 0x12, 0x4, 0x17, 0x41, 0x52, 0x1A, 0x52, 0x41, 0x51, 0x13, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x51, 0x1, 0x12, 0x1, 0x11, 0xC1, 0x4E, 0x52, 0x11, 0x9, 0x17, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x51, 0x43, 0x11, 0x1, 0x51, 0x1, 0x41, 0x3, 0x51, 0x4, 
0x51, 0x1, 0x41, 0x52, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x14, 0x4D, 0x14, 0x41, 0x11, 0x1, 0x11, 0x1, 0x41, 0x15, 0x1, 0x51, 0x13, 0x41, 0x52, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x1F, 0x16, 0x42, 0x51, 0x41, 0x1, 0x41, 0x1A, 0x41, 0x52, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x1F, 0x12, 0x52, 0x19, 0x51, 0x18, 0x41, 0x52, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x14, 0xD, 0x52, 0x13, 0x51, 0x1E, 0x41, 0x52, 0x1A, 0x1, 0x1B, 0x1, 0x52, 0x1E, 0x51, 0x13, 0x41, 0x52, 0x13, 0x7, 0xC1, 0x1B, 0x1, 0x52, 0x1F, 0x13, 0x41, 0x52, 0x13, 0x1, 0x1F, 0x13, 0x1, 0x53, 0x1F, 0x12, 0x41, 0x51, 0x14, 0xC1, 0xF, 0x3, 0xC1, 0x12, 0x52, 0x15, 0x51, 0x1A, 0x41, 0x11, 0x4, 0x1F, 0x15, 0x2, 0x11, 0x51, 0x1F, 0x11, 0x41, 0x1, 0x4F, 0x49, 0x3, 0x11, 0x51, 0x1E, 0x51, 
0x41, 0x3, 0x12, 0x51, 0x11, 0x52, 0x11, 0x54, 0x1B, 0x4, 0x51, 0x18, 0x51, 0x16, 0x41, 0x2, 0xC1, 0x13, 0x52, 0x1B, 0x51, 0x11, 0x51, 0x12, 0x51, 0x3, 0x11, 0x51, 0x1C, 0x51, 0x12, 0x41, 0x1, 0x52, 0x12, 0x1, 0x11, 0x51, 0x12, 0x4, 0x1B, 0x2, 0xC1, 0x11, 0x51, 0x1F, 0x41, 0x51, 0x14, 0x1, 0x11, 0x51, 0x12, 0x4, 0x1C, 0x43, 0x51, 0x1A, 0x51, 0x14, 0x41, 0x15, 0x1, 0x11, 0x51, 0x12, 0x4, 0x1B, 0x3, 0x11, 0x51, 0x13, 0x5, 0x17, 0x41, 0x15, 0x1, 0x11, 0x51, 0x12, 0x4, 0x41, 0x4, 0x16, 0x1, 0x31, 0x1, 0x11, 0x51, 0x13, 0x5, 0x16, 0x51, 0x41, 0x17, 0x51, 0x12, 0x4, 0x41, 0x4, 0x13, 0x6, 0x11, 0x51, 0x7, 0xC1, 0x17, 0x41, 0x1A, 0x3, 0xC1, 0x41, 0x3, 0xC1, 0x13, 0x1, 0x21, 0x1, 
//Data pointer:510

//Level 3: (Wall Huggers 2) - DONE
0x32, 0x0, 0x2C, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x1, 0x16, 0x3, 0x11, 0x3, 0x11, 0x3, 0x12, 0x4, 0x51, 0x1, 0x51, 0x1, 0x91, 0x41, 0x3, 0x41, 0x2, 0x52, 0x2, 0x52, 0x5, 0x16, 0x2, 0xC1, 0x11, 0x2, 0xC1, 0x11, 0x2, 0xC1, 0x12, 0x1, 0x12, 0x41, 0x53, 0x91, 0x51, 0x41, 0x3, 0x41, 0x2, 0x12, 0x2, 0x12, 0x3, 0x21, 0x1, 0x15, 0x1, 0x53, 0x1, 0x53, 0x1, 0x53, 0x12, 0x1, 0x12, 0x41, 0x11, 0x91, 0x53, 0x41, 0x3, 0x41, 0x1, 0x41, 0x2, 0x42, 0x1, 0xC1, 0x41, 0x4, 0x11, 0x93, 0x1D, 0x3, 0x12, 0x41, 0x53, 0x91, 0x51, 0x41, 0x3, 0x41, 0x1, 0x41, 0x2, 0x42, 0x2, 0x41, 0x4, 0x14, 0x5F, 0x53, 0x41, 0x52, 0x91, 0x51, 0x11, 0x41, 0x3, 0x41, 0x1, 0x41, 0xC1, 0x1, 0x42, 0x2, 0x41, 0x4, 0x11, 0x2, 0x12, 0x52, 0x12, 0x52, 0x13, 0x52, 0x13, 0x53, 0x41, 0x11, 0x51, 0x91, 0x51, 0x11, 0x41, 
0xC1, 0x51, 0x42, 0x1, 0x4B, 0x1, 0x11, 0x1, 0xC1, 0x1F, 0x14, 0x41, 0x11, 0x53, 0x11, 0x41, 0x12, 0x3, 0x41, 0x12, 0x3, 0x11, 0x3, 0x11, 0x1, 0x11, 0x52, 0x13, 0x1, 0x13, 0x1, 0x14, 0x1, 0x13, 0x1, 0x12, 0x41, 0x11, 0x51, 0x91, 0x51, 0x11, 0x41, 0x1, 0x45, 0x12, 0x3, 0x12, 0x1, 0x12, 0x1, 0x13, 0x4, 0x13, 0x1, 0x14, 0x1, 0x13, 0x1, 0x12, 0x41, 0x11, 0x52, 0x12, 0x41, 0x1, 0x41, 0x13, 0x41, 0x12, 0x3, 0x12, 0xC1, 0x11, 0x8, 0x91, 0x51, 0x2, 0x91, 0x51, 0xA, 0x41, 0x12, 0x51, 0x12, 0x41, 0x1, 0x41, 0x11, 0x41, 0x11, 0x41, 0x12, 0x3, 0x11, 0x52, 0x2, 0x4F, 0x41, 0x7, 0x41, 0x15, 0x41, 0x1, 0x41, 0x11, 0x41, 0x11, 0x43, 0x51, 0x12, 0x53, 0x11, 0x1, 0x51, 0x94, 0x51, 0x13, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x91, 0x6, 0x41, 0x12, 
0x1, 0x12, 0x41, 0x1, 0x12, 0x41, 0x1B, 0x1, 0x11, 0x51, 0x92, 0x51, 0x12, 0xC1, 0x2, 0x11, 0x1, 0x11, 0x2, 0xC1, 0x12, 0x5, 0x41, 0x12, 0x1, 0x12, 0x49, 0x51, 0x46, 0x1, 0x11, 0x51, 0x92, 0x13, 0x51, 0x13, 0x1, 0x13, 0x51, 0x12, 0x5, 0x41, 0x11, 0x51, 0x11, 0x51, 0x11, 0x51, 0x11, 0x51, 0x12, 0x41, 0x3, 0x11, 0x41, 0x15, 0x1, 0x12, 0x51, 0x91, 0x17, 0xC1, 0x18, 0x3, 0x41, 0x13, 0x51, 0x11, 0x51, 0x11, 0x51, 0x12, 0x41, 0x2, 0x41, 0x1, 0x41, 0x6, 0x12, 0x51, 0x91, 0x13, 0x1, 0x13, 0x51, 0x13, 0x1, 0x14, 0x91, 0x2, 0x41, 0x11, 0x1, 0x13, 0x51, 0x11, 0x51, 0x12, 0x41, 0x2, 0x41, 0x1, 0x41, 0x2, 0x16, 0x52, 0x13, 0x1, 0x17, 0x1, 0x16, 0x1, 0x41, 0x11, 0x1, 0x11, 0x1, 0x13, 0x51, 0x12, 0x41, 0x2, 0x41, 0x1, 0x41, 0x2, 0x94, 0x12, 
0x51, 0x14, 0x1, 0x13, 0x1, 0x13, 0x1, 0x12, 0x51, 0x13, 0x1, 0x41, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x14, 0x41, 0x2, 0x41, 0x4, 0x94, 0x1B, 0x1, 0x16, 0x1, 0x13, 0x1, 0x41, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x41, 0x2, 0x41, 0x1, 0x43, 0x54, 0x12, 0x1, 0xC1, 0x17, 0x1, 0x16, 0x1, 0x13, 0x1, 0x41, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x41, 0x2, 0x41, 0x1, 0x41, 0x18, 0x2, 0x1E, 0x1, 0x11, 0x51, 0x11, 0x1, 0x41, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x41, 0x12, 0x41, 0x51, 0x41, 0x4, 0x12, 0x7, 0x41, 0x51, 0x1B, 0x1, 0x11, 0x1, 0x41, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x41, 0x17, 0xA, 0xC1, 0x41, 0x51, 0x1B, 0x1, 0x11, 0x1, 0x41, 0x11, 0x1, 0x11, 0x1, 0x11, 
0x1, 0x11, 0x1, 0x12, 0x44, 0x1, 0x46, 0x6, 0x12, 0x41, 0x51, 0x13, 0x2, 0x16, 0x1, 0x11, 0x1, 0x41, 0x1A, 0x44, 0x1, 0x46, 0x4, 0xC1, 0x13, 0x41, 0x51, 0x13, 0x4, 0x16, 0x1, 0x41, 0x11, 0x7, 0xC1, 0x11, 0x52, 0x5, 0x12, 0x42, 0x2, 0x45, 0x11, 0x41, 0x14, 0x6, 0x14, 0x1, 0x41, 0x1A, 0x53, 0x3, 0x53, 0x42, 0x1, 0xC1, 0x16, 0xE, 0x11, 0x1, 0x41, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x59, 0x42, 0x1, 0x17, 0x3, 0xC1, 0x4, 0xC1, 0x4, 0xC1, 0x11, 0x1, 0x41, 0x1, 0x91, 0x1, 0x91, 0x1, 0x91, 0x1, 0x91, 0x2, 0x19, 0x7, 0x4F, 0x4F, 0x4C, 0xF, 0xF, 0xF, 0x31, 
//Data pointer:621

//Level 4 data: (Introduction to Seekers) (check gems)
0x50, 0x0, 0xFA, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x2, 0x16, 0x1, 0x11, 0x41, 0x12, 0x51, 0x1D, 0x41, 0x12, 0x51, 0x13, 0x51, 0x11, 0x3, 0x41, 0x4, 0x51, 0x81, 0x2, 0x43, 0x13, 0x1, 0x11, 0x41, 0x13, 0xD, 0x41, 0x18, 0x1, 0x41, 0x1, 0x41, 0x56, 0x2, 0x41, 0x4, 0x11, 0x1, 0x11, 0x41, 0x12, 0x1, 0x41, 0x1B, 0x1, 0x41, 0x12, 0x1, 0x13, 0x1, 0x12, 0x41, 0x1, 0x41, 0x56, 0x2, 0x41, 0x4, 0x11, 0x1, 0x11, 0x41, 0x12, 0x1, 0x41, 0x11, 0x81, 0x8, 0x11, 0x1, 0x41, 0x12, 0x1, 0x13, 0x1, 0x12, 0x41, 0x11, 0x41, 0x56, 0x21, 0x1, 0x41, 0x3, 0x81, 0x11, 0x1, 0x11, 0x41, 0x12, 0x1, 0x41, 0x11, 0x51, 0x19, 0x1, 0x51, 0x12, 0x1, 0x11, 0x51, 0x11, 0x1, 0x12, 0x41, 0x11, 0x41, 0x56, 0x43, 0x11, 0x53, 0x11, 0x1, 0x11, 0x41, 0x12, 0x1, 0x41, 0x1, 0x11, 0xA, 0x41, 0x12, 0x1, 0x16, 0x41, 0x11, 
0x41, 0x51, 0x45, 0x16, 0x51, 0x11, 0x1, 0x11, 0x41, 0x12, 0x1, 0x41, 0x2, 0x4B, 0x12, 0x1, 0x14, 0x51, 0x11, 0x41, 0x13, 0x51, 0xA, 0x11, 0x2, 0x11, 0x4, 0x41, 0x2, 0x41, 0x92, 0x11, 0x81, 0x16, 0x51, 0x11, 0x1, 0x16, 0x43, 0x1, 0x44, 0x1, 0x16, 0x1, 0x11, 0x47, 0x1, 0x42, 0x93, 0x1, 0x1B, 0x51, 0x11, 0x1, 0x11, 0x41, 0x8, 0x16, 0x1, 0x11, 0x41, 0x14, 0x51, 0x11, 0x1, 0x41, 0x93, 0x11, 0x1, 0x14, 0x51, 0x15, 0x52, 0x11, 0x1, 0x11, 0x41, 0x1, 0x41, 0x6, 0x16, 0x1, 0x11, 0x41, 0x4, 0x12, 0x1, 0x41, 0x11, 0x92, 0x11, 0x51, 0x12, 0x51, 0x14, 0x51, 0x15, 0x1, 0x11, 0x41, 0x1, 0x41, 0x6, 0x92, 0x13, 0x3, 0x41, 0x13, 0x41, 0x1, 0x11, 0x1, 0x41, 0x81, 0x11, 0x91, 0x11, 0x51, 0x14, 0x3, 0x11, 0x7, 0x41, 0x1, 0x41, 0x6, 0x93, 0x12, 
0x3, 0x41, 0x13, 0x41, 0x1, 0x11, 0x1, 0x41, 0x1, 0x11, 0x91, 0x13, 0xE, 0x41, 0x1, 0x41, 0x6, 0x95, 0x3, 0x41, 0x13, 0x41, 0x1, 0x11, 0x1, 0x41, 0x1, 0x11, 0x91, 0x11, 0x1, 0x1F, 0x41, 0x1, 0x41, 0x6, 0x4B, 0x11, 0x41, 0x3, 0x41, 0x1, 0x11, 0x91, 0x11, 0x1, 0x15, 0x51, 0x12, 0x51, 0x6, 0x41, 0x1, 0x46, 0x1, 0x91, 0x19, 0x41, 0x11, 0x45, 0x1, 0x11, 0x91, 0x11, 0x1, 0x18, 0x51, 0x11, 0x4, 0x91, 0x41, 0x7, 0x17, 0x3, 0x81, 0x41, 0x11, 0x41, 0x14, 0x51, 0x13, 0x1, 0x15, 0x1, 0x12, 0x51, 0x11, 0x3, 0x92, 0x41, 0x16, 0x41, 0x2, 0x14, 0x5, 0x41, 0x11, 0x41, 0x18, 0x1, 0x15, 0x1, 0x12, 0x51, 0x3, 0x93, 0x41, 0x91, 0x13, 0x51, 0x91, 0x41, 0x2, 0x13, 0x6, 0x41, 0x11, 0x51, 0x11, 0xE, 0x12, 0x51, 0x11, 0x81, 0x94, 0x41, 0x92, 0x51, 
0x93, 0x41, 0x2, 0x12, 0x94, 0x3, 0x41, 0x11, 0x41, 0x19, 0x4F, 0x48, 0x2, 0x11, 0x97, 0x1, 0x41, 0x11, 0x41, 0x9, 0x51, 0x9, 0x41, 0x1A, 0x51, 0x41, 0x1, 0x11, 0x98, 0x42, 0x11, 0x41, 0x8, 0x53, 0x8, 0x41, 0x15, 0x41, 0x15, 0x41, 0x1, 0x1C, 0x41, 0x15, 0x43, 0x51, 0x48, 0x2, 0x41, 0x13, 0x51, 0x11, 0x41, 0x1, 0x14, 0x41, 0xA, 0x42, 0x1, 0x41, 0x13, 0x2, 0x41, 0x1A, 0x41, 0x2, 0x41, 0x11, 0x41, 0x13, 0x41, 0x1, 0x45, 0xA, 0x11, 0x53, 0x5, 0x41, 0x11, 0x48, 0x11, 0x41, 0x2, 0x41, 0x11, 0x41, 0x13, 0x41, 0xF, 0x1, 0x11, 0x54, 0x4, 0x41, 0x11, 0x41, 0x18, 0x41, 0x2, 0x41, 0x1, 0x41, 0x13, 0x41, 0xF, 0x1, 0x11, 0x52, 0x47, 0x11, 0x41, 0x8, 0x41, 0x2, 0x41, 0x1, 0x4C, 0x5, 0x52, 0x2, 0x1B, 0x41, 0x2, 0x94, 0x2, 0x41, 0x2, 0x41, 
0x3, 0x13, 0x5, 0x41, 0x3, 0x57, 0x2, 0x4A, 0x98, 0x41, 0x2, 0x4B, 0x1, 0x41, 0x1, 0x5C, 0x2, 0x91, 0x5, 0x99, 0x41, 0x81, 0x1, 0x41, 0x31, 0x4, 0x13, 0x3, 0x41, 0x1, 
//Data pointer:550

//Level 5 data: (Introduction of Slime) - DONE
0x87, 0x0, 0x32, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x21, 0x2, 0x51, 0x4, 0x41, 0x51, 0x2, 0x71, 0x11, 0x51, 0x12, 0x51, 0x41, 0x14, 0x51, 0xA3, 0x51, 0x1A, 0x51, 0x17, 0x44, 0x1, 0x11, 0x41, 0x2, 0x11, 0x2, 0x11, 0x2, 0x18, 0x52, 0xA2, 0x51, 0x1F, 0x13, 0x1, 0x12, 0x41, 0x1, 0x11, 0x46, 0x1, 0x44, 0x51, 0x41, 0x15, 0x51, 0xA1, 0x51, 0x15, 0x51, 0x1C, 0x51, 0x1, 0x12, 0x41, 0x1, 0x11, 0x41, 0x15, 0x1, 0x11, 0x41, 0x1A, 0x51, 0x1F, 0x15, 0xC1, 0x2, 0x11, 0x71, 0x11, 0x41, 0x15, 0x1, 0x11, 0x41, 0x1F, 0x14, 0x4, 0x18, 0x47, 0x15, 0x1, 0x11, 0x41, 0x1A, 0x1, 0x18, 0x4, 0x1E, 0x49, 0x1A, 0x1, 0x19, 0x1, 0xC1, 0x1C, 0x51, 0x18, 0x51, 0x17, 0x51, 0x14, 0x1, 0x1F, 0x11, 0x51, 0x1F, 0x1D, 0x1, 0x16, 0x51, 0x1F, 0x14, 0x51, 0x1F, 0x13, 0x1, 0x1F, 0x1F, 0x1F, 0x1, 0x1F, 0x1F, 0x17, 0x51, 0x17, 
0x1, 0x1D, 0x51, 0x18, 0x51, 0x1F, 0x17, 0x1, 0x1F, 0x1F, 0x1F, 0x1, 0x1F, 0x1F, 0x1F, 0x1, 0x13, 0x51, 0x1F, 0x1D, 0x51, 0x1C, 0x1, 0x1B, 0x51, 0x1C, 0x51, 0x1F, 0x11, 0x51, 0x13, 0x1, 0x1F, 0x1F, 0x1F, 0x1, 0x1F, 0x1F, 0x14, 0x51, 0x1A, 0x1, 0x1F, 0x1F, 0x1F, 0x1, 0x18, 0x51, 0x1F, 0x1F, 0x16, 0x1, 0x1F, 0x51, 0x1F, 0x1E, 0x1, 0x12, 0x51, 0x1F, 0x1A, 0x51, 0x1A, 0x51, 0x15, 0x1, 0x1F, 0x1F, 0x1E, 0x51, 0xF, 0x6, 0x1D, 0x51, 0x19, 0x53, 0x1F, 0x14, 0x2, 0x11, 0x4F, 0x4F, 0x4C, 0x11, 0x2, 0x11, 0x41, 0x2, 0xC1, 0x2, 0xC1, 0x2, 0xC1, 0x2, 0xC1, 0x1, 0xC1, 0x1, 0xC1, 0x1, 0xC1, 0x1, 0xC1, 0x2, 0xC1, 0x2, 0xC1, 0x2, 0xC1, 0x1, 0xC1, 0x1, 0xC1, 0x1, 0xC1, 0x1, 0xC1, 0x1, 0xC1, 0x1, 0x41, 0x11, 0x2, 0x11, 0x41, 0xC1, 0x2, 0xC1, 
0x3, 0xC1, 0xF, 0xF, 0x1, 0xC1, 0x41, 0x11, 0x4, 0x51, 0x18, 0xC1, 0x1, 0xC1, 0x2, 0xC1, 0x1, 0xC1, 0x2, 0xC1, 0x2, 0xC1, 0x1, 0xC1, 0x1, 0xC1, 0x2, 0xC1, 0x1, 0xC1, 0x2, 0xC1, 0x1, 0xC1, 0x12, 0x51, 0x6, 0x11, 0x2, 0x31, 0x3, 0x1F, 0x1F, 0x13, 0x3, 
//Data pointer:309

//Level 6 data: (Seekers and Slime) - DONE
0x4B, 0x0, 0x4B, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x21, 0x2, 0x41, 0x81, 0x41, 0x81, 0x41, 0x81, 0x41, 0x2, 0x11, 0x41, 0x13, 0x41, 0x92, 0x2, 0x92, 0x11, 0x81, 0x15, 0x51, 0x14, 0x51, 0x12, 0x51, 0x12, 0x51, 0x11, 0x41, 0x51, 0x2, 0x11, 0x41, 0x1, 0x41, 0x1, 0x41, 0x1, 0x41, 0x2, 0x11, 0x41, 0x11, 0x41, 0x11, 0x41, 0x95, 0x12, 0x81, 0x1F, 0x13, 0x41, 0x51, 0x1, 0x11, 0x1, 0x41, 0x51, 0x41, 0x51, 0x41, 0x51, 0x41, 0x2, 0x51, 0x41, 0x11, 0x41, 0x11, 0x41, 0x94, 0x11, 0x1, 0x11, 0x51, 0x15, 0x1, 0x14, 0x1, 0x12, 0x1, 0x12, 0x1, 0x11, 0x41, 0x51, 0x11, 0x2, 0x17, 0x2, 0x11, 0x92, 0x41, 0x11, 0x41, 0x93, 0x11, 0x2, 0x13, 0x2, 0x12, 0x1, 0x14, 0x1, 0x12, 0x1, 0x12, 0x1, 0x11, 0x41, 0x51, 0x44, 0x1, 0x41, 0x1, 0x41, 0x1, 0x41, 0x2, 0x44, 0x11, 0x41, 0x92, 0x11, 0x3, 0x11, 0x1, 0x13, 
0x51, 0x11, 0x1, 0x14, 0x1, 0x12, 0x1, 0x12, 0x1, 0x11, 0x41, 0x51, 0x3, 0x41, 0x51, 0x45, 0x52, 0x41, 0x14, 0x42, 0x11, 0x4, 0x11, 0x1, 0x15, 0x1, 0x14, 0x1, 0x12, 0x1, 0x12, 0x1, 0x11, 0x41, 0x51, 0x3, 0x13, 0x41, 0x15, 0x5, 0x51, 0x41, 0x5, 0x11, 0x1, 0x11, 0x5, 0x14, 0x8, 0x41, 0x51, 0x1, 0x31, 0x3, 0x11, 0x41, 0x12, 0x41, 0x2, 0x45, 0x51, 0x47, 0x1, 0x4F, 0x42, 0x1, 0x41, 0x51, 0x3, 0x11, 0x1, 0x11, 0x41, 0x12, 0x41, 0x18, 0x8, 0x41, 0x15, 0x41, 0xB, 0x52, 0x14, 0x1, 0x11, 0x41, 0x12, 0x41, 0x12, 0x45, 0x9, 0x41, 0x15, 0x41, 0x1B, 0x52, 0x14, 0x1, 0x11, 0x41, 0x12, 0x41, 0x12, 0x41, 0x91, 0x41, 0x91, 0x51, 0x7, 0x92, 0x41, 0x15, 0x41, 0x12, 0x81, 0x6, 0x12, 0x52, 0x14, 0x1, 0x11, 0x41, 0x12, 0x41, 0x12, 0x41, 0x91, 0x41, 
0x91, 0x41, 0x1, 0x11, 0x4, 0x93, 0x41, 0x15, 0x41, 0x12, 0x7, 0x13, 0x51, 0x14, 0x1, 0x11, 0x41, 0x12, 0x41, 0x12, 0x41, 0x91, 0x41, 0x91, 0x41, 0x1, 0x12, 0x1, 0x95, 0x41, 0x15, 0x41, 0x12, 0x7, 0x13, 0x51, 0x16, 0x41, 0x15, 0x41, 0x91, 0x41, 0x91, 0x41, 0x71, 0x13, 0x95, 0x41, 0x15, 0x41, 0x18, 0x51, 0x14, 0x81, 0x5, 0x47, 0x51, 0x41, 0x91, 0x4B, 0x51, 0x14, 0x41, 0x1C, 0x1, 0x51, 0x12, 0x52, 0x12, 0x51, 0x11, 0x51, 0x14, 0x41, 0x9C, 0x11, 0x4, 0x41, 0x18, 0x1, 0x13, 0x1, 0x13, 0x52, 0x19, 0x41, 0x91, 0x4B, 0x1, 0x14, 0x41, 0x12, 0x4, 0x12, 0x1, 0x13, 0x2, 0x19, 0x42, 0x51, 0x44, 0x5, 0x41, 0x3, 0x41, 0x1, 0x14, 0x41, 0x12, 0x4, 0x12, 0x1, 0x13, 0x2, 0x12, 0x1, 0x16, 0x41, 0x1, 0x11, 0x1, 0x51, 0x5, 0x52, 0x81, 0x3, 0x41, 0x1, 
0x14, 0x41, 0x12, 0x4, 0x12, 0x1, 0x13, 0x2, 0x12, 0x1, 0x16, 0x41, 0x1, 0x41, 0x1, 0x41, 0x11, 0x41, 0x55, 0x45, 0x1, 0x14, 0x41, 0x12, 0x4, 0x12, 0x1, 0x13, 0x2, 0x12, 0x1, 0x16, 0x41, 0x1, 0x41, 0x51, 0x41, 0x11, 0x41, 0x55, 0x41, 0x93, 0x2, 0x14, 0x41, 0x12, 0x3, 0x81, 0x12, 0x1, 0x13, 0x2, 0x12, 0x71, 0x15, 0x51, 0x41, 0x2, 0x11, 0x41, 0x11, 0x41, 0x55, 0x41, 0x94, 0x1, 0x14, 0x41, 0x14, 0x1, 0x51, 0x1, 0x15, 0x1, 0x71, 0x19, 0x43, 0x11, 0x41, 0x11, 0x42, 0x51, 0x48, 0x1, 0x14, 0x41, 0x1F, 0x17, 0x1, 0x12, 0x41, 0x11, 0x41, 0x17, 0x4, 0x41, 0x1, 0x14, 0x41, 0xA, 0x1C, 0x1, 0x12, 0x41, 0x11, 0x44, 0x1, 0x46, 0x1, 0x41, 0x1, 0x14, 0x49, 0x2, 0x12, 0x51, 0x1, 0x11, 0x53, 0x11, 0x1, 0x12, 0x1, 0x12, 0x41, 0x3, 0x41, 0x7, 
0x41, 0x1, 0x41, 0x1, 0x1B, 0x4, 0x13, 0x1, 0x12, 0x71, 0x51, 0x14, 0x1, 0x12, 0x41, 0x3, 0x41, 0x7, 0x41, 0x1, 0x41, 0x1, 0x11, 0x51, 0x16, 0x52, 0x12, 0x41, 0x11, 0x1, 0x12, 0x2, 0x12, 0x52, 0x11, 0x1, 0x12, 0x51, 0x1, 0x11, 0x3, 0x91, 0x41, 0x7, 0x41, 0x1, 0x41, 0x71, 0x18, 0x52, 0x12, 0x41, 0x11, 0x1, 0x12, 0x2, 0x12, 0x51, 0x16, 0x4, 0x92, 0x41, 0x7, 0x41, 0x1, 0x49, 0x11, 0x53, 0x11, 0x41, 0x11, 0x1, 0x12, 0x4, 0x11, 0x9, 0x93, 0x41, 0x7, 0x41, 0x9, 0x13, 0x53, 0x41, 0x11, 0x4, 
//Data pointer:606

//Level 7 data: (Introduction of gas) - DONE
0x50, 0x0, 0xA, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x3, 0x41, 0x63, 0x13, 0x51, 0x12, 0x51, 0x41, 0x11, 0x51, 0x13, 0x53, 0x92, 0x62, 0x93, 0x51, 0xC1, 0x68, 0x41, 0x95, 0x3, 0x41, 0x63, 0x17, 0x41, 0x13, 0x51, 0x13, 0x51, 0x93, 0x61, 0x93, 0x51, 0x47, 0x62, 0x41, 0x95, 0x1, 0x31, 0x1, 0x41, 0x51, 0x61, 0x14, 0x1, 0x13, 0x41, 0x17, 0x51, 0x96, 0x51, 0x12, 0x41, 0x64, 0x44, 0x95, 0x4, 0x51, 0x61, 0x14, 0x1, 0x13, 0x41, 0x17, 0x51, 0x95, 0x51, 0x13, 0x41, 0x67, 0xC1, 0x51, 0x94, 0x11, 0x1, 0x42, 0x62, 0x13, 0x2, 0x12, 0x51, 0x42, 0x17, 0x51, 0x94, 0x51, 0x11, 0x51, 0x11, 0x49, 0x51, 0x94, 0x11, 0x1, 0x41, 0x11, 0x62, 0x11, 0x63, 0xC1, 0x11, 0x1, 0x12, 0x41, 0x13, 0x51, 0x14, 0x54, 0x14, 0x51, 0x17, 0x42, 0x51, 0x93, 0x11, 0x1, 0x41, 0x18, 0x43, 0x11, 0x41, 0x1F, 0x15, 0x51, 0x15, 0x51, 0x92, 0x12, 
0x1, 0x41, 0x6, 0x12, 0x41, 0x3, 0x41, 0x18, 0x4, 0x1F, 0x52, 0x11, 0x2, 0x41, 0x18, 0x41, 0x3, 0x41, 0x18, 0x4, 0x1E, 0x1, 0x13, 0x2, 0x41, 0x18, 0x41, 0xC1, 0x1, 0xC1, 0x41, 0x52, 0x14, 0x51, 0x11, 0x4, 0x1C, 0x51, 0x11, 0x3, 0x11, 0x2, 0x4A, 0x93, 0x41, 0x52, 0x16, 0x4, 0x19, 0x51, 0x14, 0x3, 0x11, 0x6, 0x51, 0x11, 0x51, 0x12, 0x51, 0x93, 0x41, 0x52, 0x16, 0x4, 0x1E, 0x3, 0x11, 0x3, 0x42, 0x1, 0x41, 0x14, 0x57, 0x16, 0x4, 0x1F, 0x2, 0x11, 0x3, 0x44, 0x1F, 0x12, 0x4, 0x13, 0x53, 0x19, 0x2, 0x11, 0x3, 0x41, 0x51, 0x13, 0x1, 0x13, 0x63, 0x11, 0x42, 0x16, 0x4, 0x13, 0x53, 0x4C, 0x1, 0x11, 0x1, 0x41, 0x14, 0x1, 0x13, 0x3, 0x11, 0x41, 0x17, 0x4, 0x13, 0x53, 0x41, 0x12, 0x51, 0x15, 0x53, 0x1, 0x11, 0x1, 0x41, 0x1, 0x13, 0x1, 
0x13, 0x3, 0x11, 0x41, 0x17, 0x4, 0x14, 0x52, 0x41, 0x12, 0x71, 0x65, 0x52, 0x41, 0x1, 0x11, 0x1, 0x41, 0x1, 0x13, 0x1, 0x12, 0x3, 0x51, 0x42, 0x13, 0x51, 0x13, 0x4, 0x16, 0x3, 0x11, 0x64, 0x53, 0x41, 0x1, 0x11, 0x1, 0x41, 0x1, 0x13, 0x1, 0x11, 0x3, 0x52, 0x41, 0x14, 0x51, 0x12, 0x5, 0x13, 0x3, 0x41, 0x12, 0x51, 0x64, 0x13, 0x2, 0x11, 0x1, 0x41, 0x1, 0x13, 0x4, 0x53, 0x41, 0x17, 0x5, 0x4F, 0x42, 0x2, 0x11, 0x1, 0x41, 0x1, 0x13, 0x3, 0x54, 0x41, 0x15, 0x51, 0x11, 0x2, 0x53, 0x41, 0xD, 0x91, 0x11, 0x41, 0x2, 0x11, 0x1, 0x41, 0x6, 0x55, 0x41, 0x17, 0x1, 0x54, 0x41, 0x1, 0xC1, 0xA, 0x92, 0x11, 0x41, 0x4, 0x41, 0x6, 0x4F, 0x41, 0x52, 0x41, 0x52, 0x1C, 0x52, 0x4, 0x41, 0x6, 0x41, 0x95, 0x14, 0x54, 0x12, 0x52, 0x41, 0x52, 0x16, 
0x51, 0x11, 0x51, 0x11, 0x51, 0x13, 0x4, 0x48, 0x94, 0x12, 0x93, 0x14, 0x92, 0x15, 0x64, 0x18, 0x1, 0x12, 0x5, 0x41, 0x51, 0x13, 0x41, 0x93, 0x52, 0x14, 0x4, 0x44, 0x11, 0x2, 0x12, 0x62, 0x12, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x16, 0x1, 0x41, 0x51, 0x13, 0x41, 0x92, 0x11, 0x53, 0x13, 0x4, 0x41, 0x3, 0x11, 0x2, 0x12, 0x62, 0x12, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x43, 0x11, 0x1, 0x41, 0x51, 0x13, 0x41, 0x13, 0x51, 0x15, 0x4, 0x41, 0x91, 0x2, 0x11, 0x2, 0x12, 0x62, 0x12, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x1, 0x12, 0x3, 0x11, 0x1, 0x41, 0x51, 0x13, 0x45, 0x11, 0x42, 0x12, 0x4, 0x41, 0x92, 0x1, 0x11, 0x2, 0x12, 0x62, 0x12, 0x1, 0x11, 0x1, 0x11, 0x1, 0x11, 0x4, 0x21, 0x1, 0x11, 0x1, 0x12, 0x3, 0x11, 0x66, 0x41, 
0x12, 0x63, 0xC1, 0x41, 0x93, 0x11, 0x2, 0x12, 0x6D, 
//Data pointer:529

//Level 8 data: (Gas chase, crawlers and seekers) - DONE
0x1E, 0x0, 0x32, 0x0, 0x0, 0x0, 0x0, 0x0, 
0xA, 0x41, 0x13, 0x4, 0x51, 0x64, 0x41, 0x1, 0xC1, 0x11, 0x2, 0x16, 0x71, 0x13, 0x62, 0x12, 0x5, 0x41, 0x2, 0x41, 0x4, 0x41, 0x13, 0x3, 0x41, 0x51, 0x11, 0x63, 0x41, 0x2, 0x11, 0x2, 0x1A, 0x62, 0x12, 0x1, 0x21, 0x3, 0x41, 0x2, 0x41, 0x4, 0x41, 0x13, 0x3, 0x41, 0x51, 0x11, 0x63, 0x41, 0x2, 0x11, 0x1, 0xC1, 0x1A, 0x62, 0x12, 0x5, 0x41, 0x2, 0x41, 0x4, 0x41, 0x13, 0x3, 0x41, 0x51, 0x11, 0x62, 0xC1, 0x41, 0x2, 0x11, 0x2, 0x1A, 0x62, 0x15, 0x5, 0x41, 0x4, 0x41, 0x13, 0x3, 0x41, 0x51, 0x14, 0x41, 0x2, 0x11, 0x2, 0x16, 0x6B, 0x5, 0x41, 0x4, 0x51, 0x6, 0x41, 0x51, 0x12, 0x52, 0x41, 0x2, 0x11, 0x2, 0x16, 0x6A, 0xC1, 0x2, 0x41, 0x7, 0x41, 0x6, 0x41, 0x51, 0x12, 0x52, 0x41, 0x2, 0x11, 0x2, 0x16, 0x63, 0x58, 0x2, 0x41, 0x7, 0x41, 
0x13, 0x3, 0x41, 0x51, 0x12, 0x52, 0x41, 0x2, 0x11, 0x2, 0x16, 0xC1, 0x61, 0x59, 0x2, 0x41, 0x92, 0x41, 0x4, 0x41, 0x13, 0x3, 0x41, 0x51, 0x42, 0x52, 0x41, 0x2, 0x11, 0x1, 0xC1, 0x5F, 0x52, 0x2, 0x41, 0x12, 0x41, 0x4, 0x41, 0x13, 0x3, 0x11, 0x51, 0x14, 0x2, 0xC1, 0x5E, 0x16, 0x2, 0x41, 0x12, 0x41, 0x4, 0x41, 0x13, 0x4, 0x11, 0x3, 0x59, 0x1F, 0x2, 0x41, 0x11, 0x91, 0x41, 0x4, 0x41, 0x17, 0x71, 0x2, 0x59, 0x1F, 0x11, 0x2, 0x41, 0x12, 0x4F, 0x4F, 0x46, 0x52, 0x43, 0x2, 0x41, 0x6, 0x41, 0x57, 0x41, 0x9, 0x51, 0x17, 0x1, 0x41, 0x16, 0x63, 0x2, 0x41, 0x3, 0x93, 0x42, 0x55, 0x41, 0x11, 0x68, 0x51, 0x71, 0x51, 0x5, 0x11, 0xC1, 0x41, 0x12, 0x42, 0x65, 0x2, 0x41, 0x1, 0x95, 0x51, 0x1, 0x41, 0x53, 0x41, 0x12, 0x68, 0x13, 0x6, 0x51, 0x41, 
0x12, 0x41, 0x66, 0x2, 0x48, 0x1, 0x41, 0x52, 0x41, 0x51, 0x12, 0x68, 0x11, 0x1, 0x42, 0x12, 0x2, 0x11, 0x51, 0x41, 0x12, 0x41, 0x66, 0xB, 0x52, 0x41, 0x52, 0x12, 0x68, 0x11, 0x1, 0x11, 0x41, 0x12, 0x2, 0x11, 0x51, 0x41, 0x12, 0x41, 0x66, 0x4, 0x43, 0x4, 0x12, 0x41, 0x14, 0x68, 0x11, 0x1, 0x11, 0x41, 0x12, 0x2, 0x11, 0x51, 0x41, 0x12, 0x41, 0x63, 0x41, 0x62, 0x4, 0x41, 0x51, 0x41, 0x9, 0x51, 0x41, 0xC1, 0x69, 0x11, 0x41, 0x12, 0x3, 0x51, 0x41, 0x12, 0x41, 0x63, 0x41, 0x62, 0x45, 0x51, 0x47, 0x54, 0x41, 0x1B, 0x41, 0x12, 0x3, 0x11, 0x3, 0x41, 0x61, 0x71, 0x61, 0x41, 0x62, 0x53, 0x11, 0x1, 0x11, 0x7, 0x54, 0x4F, 0x4C, 0x62, 0x13, 0x2, 0x41, 0x6, 0x11, 0x54, 0x11, 0xF, 0xD, 0x13, 0x1, 0x11, 0x7, 0x16, 0xF, 0xD, 0x63, 0x43, 0x52, 0x4F, 
0x4F, 0x48, 0x63, 0x51, 0x62, 0x12, 0x62, 0x11, 0x41, 0x63, 0x52, 0xF, 0x6, 0x14, 0x51, 0x3, 0x63, 0x41, 0x66, 0x11, 0x41, 0x56, 0x13, 0x71, 0x51, 0x43, 0xC, 0x13, 0x91, 0x41, 0x3, 0x63, 0x41, 0x66, 0x11, 0x41, 0x57, 0x16, 0x41, 0x51, 0xB, 0x12, 0x92, 0x51, 0x3, 0x63, 0x41, 0x6, 0x14, 0x53, 0x14, 0x91, 0x44, 0x1E, 0x92, 0x41, 0x1, 0x31, 0x1, 0x62, 0xC1, 0x41, 0x1F, 0x12, 0x91, 0x18, 0x8, 0x11, 0x93, 0x51, 0xC1, 0x1, 0xC1, 
//Data pointer:465




//Level 9 data: (Introduction to Ameobas) - WIP




};

uint8_t tiles[128] {			//RAM used for animated game tiles

//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0x51, 0xaa, 0x55, 0xaa, 0x15, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x18, 0x84, 0xe4, 0x3f, 0x3f, 0xe4, 0x84, 0x18, 0x77, 0x07, 0x77, 0x70, 0x77, 0x07, 0x77, 0x70, 0x1c, 0x32, 0x7d, 0x7d, 0x6f, 0x3e, 0x1c, 0x00, 0x3a, 0x7d, 0x75, 0x45, 0x75, 0x7d, 0x3a, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x63, 0x7f, 0x00, 0x00, 0x42, 0x3c, 0x24, 0x24, 0x3c, 0x42, 0x00, 0x00, 0x18, 0x66, 0x81, 0x81, 0x66, 0x18, 0x00, 0xf9, 0xff, 0x6f, 0x46, 0x6e, 0x7f, 0xff, 0xdd, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x7c, 0xc0, 0x98, 0x2c, 0x34, 0x19, 0x03, 0x3e, 0x00, 0x10, 0x14, 0x68, 0x16, 0x28, 0x08, 0x00, 0x58, 0x82, 0x09, 0x20, 0x04, 0x91, 0x81, 0x6a, 0x08, 0x80, 0x01, 0x00, 0x00, 0x01, 0x80, 0x04, 
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0x51, 0xaa, 0x55, 0xaa, 0x15, 0xaa, 0x18, 0x84, 0xe4, 0x3f, 0x3f, 0xe4, 0x84, 0x18, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x63, 0x7f, 0x00, 0x77, 0x07, 0x77, 0x70, 0x77, 0x07, 0x77, 0x70, 0x1c, 0x32, 0x7d, 0x7d, 0x6f, 0x3e, 0x1c, 0x00, 0x00, 0x0e, 0x03, 0xb1, 0xb1, 0x1b, 0x0e, 0x00, 0x3a, 0x7d, 0x75, 0x45, 0x75, 0x7d, 0x3a, 0x00, 0x00, 0x42, 0x3c, 0x24, 0x24, 0x3c, 0x42, 0x00, 0x00, 0x18, 0x66, 0x81, 0x81, 0x66, 0x18, 0x00, 0xf9, 0xff, 0x6f, 0x46, 0x6e, 0x7f, 0xff, 0xdd, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x7c, 0xc0, 0x98, 0x2c, 0x34, 0x19, 0x03, 0x3e, 0x00, 0x10, 0x14, 0x68, 0x16, 0x28, 0x08, 0x00, 0x58, 0x82, 0x09, 0x20, 0x04, 0x91, 0x81, 0x6a, 0x08, 0x80, 0x01, 0x00, 0x00, 0x01, 0x80, 0x04, 

0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0x51, 0xaa, 0x55, 0xaa, 0x15, 0xaa, 0x18, 0x84, 0xe4, 0x3f, 0x3f, 0xe4, 0x84, 0x18, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x63, 0x7f, 0x00, 0x77, 0x07, 0x77, 0x70, 0x77, 0x07, 0x77, 0x70, 0x1c, 0x32, 0x7d, 0x7d, 0x6f, 0x3e, 0x1c, 0x00, 0x18, 0x0c, 0x7e, 0x43, 0x7e, 0x0c, 0x18, 0x00, 0x3a, 0x7d, 0x75, 0x45, 0x75, 0x7d, 0x3a, 0x00, 0x00, 0x42, 0x3c, 0x24, 0x24, 0x3c, 0x42, 0x00, 0x00, 0x18, 0x66, 0x81, 0x81, 0x66, 0x18, 0x00, 0xf9, 0xff, 0x6f, 0x46, 0x6e, 0x7b, 0xff, 0xdd, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x7c, 0xc0, 0x98, 0x2c, 0x34, 0x19, 0x03, 0x3e, 0x00, 0x10, 0x14, 0x68, 0x16, 0x28, 0x08, 0x00, 0x58, 0x82, 0x09, 0x20, 0x04, 0x91, 0x81, 0x6a, 0x08, 0x80, 0x01, 0x00, 0x00, 0x01, 0x80, 0x04, 

};

const uint8_t font[] PROGMEM = {    //The text font

0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0xde, 0xde, 0x00, 0x00, 0x00, 0x1e, 0x1e, 0x00, 0x00, 0x1e, 0x1e, 0x00, 0x00, 0x6c, 0xfe, 0xfe, 0x6c, 0xfe, 0xfe, 0x6c, 0x00, 0x48, 0x5c, 0x54, 0xfe, 0x54, 0x74, 0x24, 0x00, 0x7e, 0x02, 0x0c, 0x02, 0x7e, 0x00, 0x7c, 0x0a, 0x7c, 0x00, 0x42, 0x24, 0x18, 0x24, 0x42, 0x00, 0x20, 0x18, 0x18, 0x0c, 0x18, 0x18, 0x20, 0x00, 0x00, 0x00, 0x7c, 0xfe, 0xc6, 0x82, 0x00, 0x00, 0x00, 0x82, 0xc6, 0xfe, 0x7c, 0x00, 0x00, 0x18, 0x84, 0xe4, 0x3f, 0x3f, 0xe4, 0x84, 0x18, 0x00, 0x18, 0x18, 0x7e, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xe0, 0x60, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xe0, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x04, 0x00, 0x00, 0x7c, 0xfe, 0xfe, 0xfe, 0x82, 0xfe, 0x7c, 0x00, 0x00, 0x0c, 0xfc, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0xc4, 0xe6, 0xf2, 0xde, 0xde, 0xde, 0xcc, 0x00, 0x44, 0xd6, 0x92, 0xfe, 0xfe, 0xfe, 0x7c, 0x00, 0x3e, 0x3e, 0x30, 0x3e, 0xfe, 0xfe, 0x30, 0x00, 0x5e, 0xde, 0xda, 0xda, 0xda, 0xfa, 0x72, 0x00, 0x7c, 0xfe, 0x8a, 0xfa, 0xfa, 0xfa, 0x72, 0x00, 0x02, 0x02, 0xf2, 0xfa, 0xfe, 0x0e, 0x06, 0x00, 0x6c, 0xfe, 0x92, 0xfe, 0xfe, 0xfe, 0x6c, 0x00, 0x1c, 0xbe, 0xa2, 0xfe, 0xfe, 0xfe, 0x7c, 0x00, 0x00, 0x00, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x80, 0xec, 0xec, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x00, 0x00, 0x00, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x0c, 0x06, 0xd2, 0xda, 0xde, 0x0e, 0x04, 0x00, 0x7c, 0xfe, 0xc6, 0xba, 0xaa, 0xb6, 0xbc, 0x00, 0xfc, 0xfe, 0x12, 0xfe, 0xfe, 0xfe, 0xfc, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x92, 0xfe, 0x6c, 0x00, 0x7c, 0xfe, 0xfe, 0xfe, 0x82, 0xc6, 0x44, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x82, 0xfe, 0x7c, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x92, 0x92, 0x82, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x12, 0x12, 0x02, 0x00, 0x7c, 0xfe, 0xfe, 0xfe, 0x82, 0xa6, 0xe4, 0x00, 0xfe, 0xfe, 0x10, 0xfe, 0xfe, 0xfe, 0xfe, 0x00, 0x82, 0xfe, 0xfe, 0xfe, 0xfe, 0x82, 0x00, 0x00, 0x40, 0xc2, 0x82, 0xfe, 0xfe, 0x7e, 0x02, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x38, 0xee, 0xc6, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x80, 0x80, 0x80, 0x00, 0xfe, 0xfe, 0x1e, 0xfc, 0x1e, 0xfe, 0xfe, 0x00, 0xfe, 0xfe, 0xfe, 0x1c, 0x38, 0xfe, 0xfe, 0x00, 0x7c, 0xfe, 0x82, 0xfe, 0xfe, 0xfe, 0x7c, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x22, 0x3e, 0x1c, 0x00, 0x7c, 0xfe, 0xa2, 0xfe, 0xfe, 0xfe, 0x7c, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x22, 0xfe, 0xdc, 0x00, 0x4c, 0xde, 0x9e, 0xfe, 0xf2, 0xf6, 0x64, 0x00, 0x02, 0x02, 0xfe, 0xfe, 0xfe, 0x02, 0x02, 0x00, 0x7e, 0xfe, 0x80, 0xfe, 0xfe, 0xfe, 0x7e, 0x00, 0x3e, 0x7e, 0xe0, 0xfe, 0xfe, 0x7e, 0x3e, 0x00, 0x7e, 0xfe, 0xe0, 0x7c, 0xe0, 0xfe, 0x7e, 0x00, 0xc6, 0xee, 0x7c, 0x38, 0x7c, 0xee, 0xc6, 0x00, 0x0e, 0xfe, 0xfe, 0xf8, 0xfe, 0xfe, 0x0e, 0x00, 0xe2, 0xf2, 0xfa, 0xfe, 0xbe, 0x9e, 0x8e, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x00, 0xc3, 0x81, 0x00, 0x00, 0x00, 0x00, 0x81, 0xc3, 0x00, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x24, 0x66, 0xe7, 0xe7, 0x66, 0x24, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0x7e, 0x3c, 0x18, 0x00, 
};

const uint8_t aniTiles[] PROGMEM = {	//The data for animating enemies in the tiles RAM

0x10, 0x80, 0x02, 0x00, 0x00, 0x00, 0x40, 0x04, 0x3a, 0x7d, 0x75, 0x45, 0x75, 0x7d, 0x3a, 0x00, 0x00, 0x42, 0x3c, 0x24, 0x24, 0x3c, 0x42, 0x00, 0x00, 0x18, 0x66, 0x81, 0x81, 0x66, 0x18, 0x00, 0xf9, 0xff, 0x6f, 0x46, 0x6e, 0x7b, 0xff, 0xdd, 0x66, 0x99, 0x81, 0x82, 0x81, 0x49, 0x21, 0x1e, 0x7e, 0x21, 0x18, 0x34, 0x2c, 0x18, 0x84, 0x7e, 

0x00, 0x12, 0x80, 0x00, 0x00, 0x40, 0x04, 0x00, 0x3a, 0x7d, 0x75, 0x45, 0x76, 0x7d, 0x3a, 0x00, 0x00, 0x00, 0x7e, 0x24, 0x24, 0x7e, 0x00, 0x00, 0x00, 0x18, 0x7e, 0x87, 0x81, 0x66, 0x18, 0x00, 0x78, 0xef, 0xef, 0xfe, 0x7e, 0xfa, 0xff, 0x57, 0x0c, 0x32, 0x41, 0x81, 0xa1, 0x82, 0x82, 0x7c, 0x06, 0x03, 0x99, 0xb5, 0xad, 0x99, 0xc0, 0x60, 

0x02, 0x00, 0x10, 0x80, 0x20, 0x04, 0x00, 0x00, 0x3a, 0x7d, 0x75, 0x45, 0x75, 0x7d, 0x3a, 0x00, 0x00, 0x00, 0x3c, 0x7e, 0x7e, 0x3c, 0x00, 0x00, 0x00, 0x18, 0x66, 0xf1, 0x8f, 0x66, 0x18, 0x00, 0xf9, 0xef, 0x7f, 0x7a, 0x7a, 0x51, 0xfb, 0xdd, 0x3e, 0x41, 0x92, 0x82, 0x82, 0x81, 0x41, 0x3e, 0x40, 0x81, 0x9b, 0xad, 0xb5, 0xd9, 0x81, 0x02, 

0x00, 0x09, 0x40, 0x00, 0x00, 0x20, 0x02, 0x00, 0x3a, 0x7d, 0x76, 0x45, 0x75, 0x7d, 0x3a, 0x00, 0x00, 0x00, 0x7e, 0x24, 0x24, 0x7e, 0x00, 0x00, 0x00, 0x18, 0x66, 0x81, 0xe1, 0x7e, 0x18, 0x00, 0x52, 0xfd, 0x7f, 0xee, 0xfa, 0xf1, 0x7b, 0x9d, 0x1c, 0x22, 0x41, 0x89, 0x82, 0x81, 0x4d, 0x32, 0x7c, 0xc0, 0x98, 0x2c, 0x34, 0x19, 0x03, 0x3e, 
	
};

const uint8_t mani[] PROGMEM = {	//The data for animatin the main character
	
0x18, 0x84, 0xe4, 0x3f, 0x3f, 0xe4, 0x84, 0x18, 0x10, 0x08, 0x04, 0xff, 0x87, 0x08, 0x08, 0x00, 0x00, 0xd8, 0xa4, 0x1f, 0x2b, 0xc8, 0x80, 0x00, 0xc0, 0xa0, 0x1c, 0x1f, 0x1b, 0x20, 0xc0, 0x80, 0x00, 0x83, 0xe4, 0x1f, 0x1f, 0x24, 0x24, 0x00, 0x00, 0x42, 0x64, 0x1f, 0x1f, 0x64, 0x42, 0x00, 0x00, 0x24, 0x24, 0x1f, 0x1f, 0xe4, 0x83, 0x00, 0x10, 0x88, 0xe4, 0x1f, 0x1f, 0x34, 0x24, 0x00, 0x00, 0x48, 0x64, 0x1f, 0x1f, 0x64, 0x48, 0x00, 0x00, 0x24, 0x34, 0x1f, 0x1f, 0xe4, 0x88, 0x10, 0x40, 0x20, 0x40, 0x3f, 0x1b, 0x28, 0xc8, 0x88, 0x00, 0x00, 0x00, 0xfc, 0xbf, 0x8b, 0x08, 0x0c, 0xc0, 0xa0, 0x10, 0x1c, 0x1f, 0x6b, 0x48, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

};

const uint8_t doori[] PROGMEM = {
0x00, 0x7f, 0x41, 0x41, 0x41, 0x41, 0x7f, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x63, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t title[] PROGMEM = {
0x00, 0xff, 0x01, 0x01, 0x81, 0xc1, 0xe1, 0xf1, 0x31, 0x19, 0x19, 0x09, 0x09, 0x09, 0x19, 0x39, 0x01, 0x01, 0x01, 0x81, 0xe1, 0x39, 0x39, 0xf1, 0xc1, 0x01, 0x09, 0xf9, 0xf9, 0x09, 0x09, 0x99, 0xf9, 0xf9, 0x71, 0x01, 0x09, 0xf9, 0xf9, 0x09, 0x09, 0x99, 0xf9, 0x71, 0x01, 0x01, 0x01, 0x81, 0xe1, 0x39, 0x39, 0xf9, 0xc1, 0x01, 0x01, 0xc1, 0xe1, 0xf1, 0x31, 0x19, 0x09, 0x09, 0x09, 0x19, 0x31, 0x01, 0x09, 0xf9, 0xf9, 0x89, 0xc9, 0x19, 0x01, 0x01, 0x01, 0x01, 0x09, 0xf9, 0xf9, 0x79, 0xf1, 0xc1, 0x81, 0xe1, 0x39, 0xf9, 0xf9, 0x09, 0x01, 0x09, 0xf9, 0xf9, 0x09, 0x01, 0x09, 0xf9, 0xf9, 0x79, 0xf1, 0xe1, 0x09, 0xf9, 0xf9, 0x09, 0x01, 0x09, 0xf9, 0xf9, 0x89, 0xc9, 0x19, 0x01, 0x09, 0xf9, 0xf9, 0xf9, 0x09, 0x09, 0x09, 0x19, 0xf9, 0xf1, 0xe1, 0x01, 0x01, 0x01, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x3f, 0x7f, 0x70, 0xc0, 0xc0, 0x80, 0x82, 0xc2, 0xfe, 0xfe, 0x7e, 0x02, 0x18, 0x1e, 0x17, 0x11, 0x01, 0x01, 0x13, 0x1f, 0x1e, 0x18, 0x1f, 0x1f, 0x11, 0x03, 0x0f, 0x1f, 0x1e, 0x1c, 0x10, 0x10, 0x1f, 0x1f, 0x11, 0x11, 0x11, 0x1f, 0x0e, 0x14, 0x18, 0x1e, 0x17, 0x11, 0x01, 0x01, 0x13, 0x1f, 0x1f, 0x18, 0x13, 0x07, 0x0f, 0x1c, 0x18, 0x10, 0x11, 0x1f, 0x1f, 0x0f, 0x01, 0x10, 0x1f, 0x1f, 0x10, 0x11, 0x10, 0x18, 0x00, 0x00, 0x00, 0x10, 0x1f, 0x1f, 0x10, 0x01, 0x0f, 0x07, 0x10, 0x10, 0x1f, 0x1f, 0x10, 0x00, 0x10, 0x1f, 0x1f, 0x10, 0x00, 0x10, 0x1f, 0x1f, 0x10, 0x03, 0x0f, 0x1e, 0x1f, 0x1f, 0x00, 0x00, 0x10, 0x1f, 0x1f, 0x10, 0x11, 0x10, 0x18, 0x80, 0xff, 0xff, 0xff, 0x84, 0x0c, 0x3c, 0x7e, 0xff, 0xf3, 0xc1, 0x80, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0xcf, 0xcf, 0xc7, 0xc7, 0xe7, 0xe7, 0xe7, 0xe7, 0x67, 0x77, 0x7f, 0x63, 0x3e, 0x00, 0xfe, 0xfe, 0xff, 0x0f, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0f, 0xff, 0x02, 0xfe, 0x00, 0xe0, 0xf0, 0xf8, 0xf8, 0xbc, 0x9e, 0x9e, 0x8f, 0x87, 0x87, 0xff, 0x01, 0xff, 0x80, 0x80, 0x00, 0x3e, 0x7e, 0x7f, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0xff, 0x06, 0xfc, 0x00, 0x80, 0x40, 0x40, 0x40, 0x40, 0x80, 0x00, 0xc0, 0x80, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x7f, 0x40, 0x40, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x40, 0x40, 0x40, 0x4f, 0x4f, 0x4b, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4e, 0x40, 0x47, 0x47, 0x4f, 0x4b, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4b, 0x4f, 0x44, 0x47, 0x40, 0x43, 0x43, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x4f, 0x48, 0x4f, 0x43, 0x43, 0x40, 0x42, 0x4e, 0x4e, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4f, 0x46, 0x43, 0x40, 0x47, 0x49, 0x49, 0x49, 0x49, 0x49, 0x40, 0x4f, 0x40, 0x40, 0x40, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x40, 0x40, 0x7f, 0x00, 
};

//Arduboy system specific variables
uint16_t frameCount;
#define eachFrameMillis			16		//Static framerate 60 FPS
unsigned long lastFrameStart;
unsigned long nextFrameStart;
bool justRendered;
uint8_t lastFrameDurationMs;

//Game world RAM
uint8_t tileMap[48][32];                         //1 byte per tile, (2) screens at 16x8 each
uint8_t scratch[16];			//Scratch line of RAM. Used for the edit menu and status bar (when active)

//Player movement and positioning
int8_t winX;              //X window position
int8_t winY;              //Y window position
int8_t winXFine;
int8_t winYFine; 
uint8_t scrollLeft = 0;
uint8_t scrollRight = 0;
uint8_t scrollUp = 0;
uint8_t scrollDown = 0;
uint8_t scrollFlag = 0;
uint8_t doorX;					//XY position of exit door
uint8_t doorY;
uint8_t manStartX;				//XY position of where man starts
uint8_t manStartY;
uint8_t	scanX;
uint8_t	scanY;

uint8_t pX = 8;                 //Player XY position
uint8_t pY = 4;
uint8_t manDir = 0;				//Which direction the man is facing
uint8_t manFrame = 0;			//Which frame of man animation we're on
uint8_t push = 0;				//Counter for pushing rocks
uint8_t playerState = 0;		//0 = waiting for spawn 1 = alive 2 = dead
uint16_t screenTimer = 0;		//Timer for changing screen events

uint8_t debug = 0;				//Enable debug mode (default = off)
uint8_t cursorX;				//Cursor position after drawing a number
uint8_t editMode = 0;			//If we're editing or not (changes the action of B button during game)

int g;							//A stock variable
int gg;							//A stock variable

uint16_t ePoint;				//Current pointer for EEPROM access. Must start at 16 or higher because of Arduboy reserved functions
uint8_t eeByte;					//Used for sending bytes to and fro EEPROM
uint8_t *ringPt[8];				//Pointer to the bytes that surround the current tile we're evaluating
uint8_t eventCounter = 0;       //When to trigger events such as player movement and world physics
uint8_t aniPointer;				//Pointer for current block of tile animation. 40 byte increments, max 120 (160 trigger reset back to 0)
uint8_t rollToggle;				//Which way balls should roll off each other this frame

uint8_t dPadBounce = 0;		
uint8_t debounce = 0;

//World object variables
uint8_t slimeTimer = 0;			//How many slime tiles 
uint8_t slimeGrow = 250;		//How fast slime expands (lower = faster)
uint8_t slimeExpand = 0;		//When slime expands, on which side?
uint16_t gemsNeeded = 50;		//How many to open door
uint16_t gemsCollected = 0;
uint16_t gemsTotal;				//Total # of gems in map. Is counted on decompress. Can go up when monsters turned into diamonds

uint8_t sysState = game;
uint8_t dirtSound;

uint8_t *cP;         			//Pointer to character data

//RGB LED variables
uint8_t red = 51;
uint8_t colorFrame = 0;
uint8_t flash = 0;
	
//Editor variables
int8_t tilePlace = 0;			//The tile to place
uint8_t tileBackup;				//The tile we're hovering over
uint8_t menuSelect = 0;			//Which menu to display when holding B (starts at 0)
uint8_t moveRamp = 10;
uint8_t moveRampStart = 10;
uint8_t exportTarget = 0;		//Writing - 0 == EEPROM 1 = Serial Port  Reading - 0 = EEPROM 1 = Indexed flash level data
uint8_t itemsPerLine = 0;
uint16_t totalCount = 0;		//How many bytes of level data were written to the record (includes the 16 byte header)
uint8_t arrows[2];

uint16_t tonePitch;
uint16_t toneTimer = 0;
uint8_t tonePriority = 0;		//10 = highest (sfx) 0 = lowest (music) -1 off
int8_t toneDir;

void setup() {
	
	Serial.begin(115200);

	a.boot();				//Arduboy framework

	//eachFrameMillis = 16;     //a.setFrameRate(60);  
	
	//Setup "beep2" pin
	TCCR4A = 0; 				// normal mode. Disable PWM
	TCCR4B = 0b00000100;
	TCCR4D = 0; 				// normal mode
	TC4H = 0;  					// toggle pin at count = 0
	OCR4A = 0; 					//  "
  
	// Timer0 is already used for millis() - we'll just interrupt somewhere - Adafruit example
	// in the middle and call the "Compare A" function below
	OCR0A = 0xAF;
	TIMSK0 |= _BV(OCIE0A);
  
	pinMode(RED_LED, 1);				//PB6
	pinMode(GREEN_LED, 1);			//PB7
	pinMode(BLUE_LED, 1);				//PB5

	//eventCounter = 0;

	//walls();

	menuSetup();			//Start in the Menu state
	
}

void loop() {

  if (!(nextFrame())) {         //Lock to 60 FPS
    return;
  } 

  //beep.timer(); // handle tone duration  
	
	switch(sysState) {
	
		case(menu):
			mainMenu();
		break;
		case(storyTime):
		
		break;
		case(game):
			gameLoop();
		break;
		case(edit):
			editLoop();
		break;
		case(levelStart):
			levelStartLoop();
		break;
	
	}

}

void tone(uint16_t thePitch, uint16_t theTime, uint8_t newPriority, int direction) {

	if (newPriority < tonePriority) {					//A "more important" sound is playing? (some sounds are more equal than others)
		return;											//Abort
	}

	toneDir = direction;	
	tonePriority = newPriority;						//Playing? Set as new priority

	TCCR4A = bit(COM4A0); 								// set toggle on compare mode (which connects the pin)
	TC4H = highByte(thePitch); 							// load the count (10 bits),
	OCR4C = lowByte(thePitch); 							//  which determines the frequency
  
	tonePitch = thePitch;
	toneTimer = theTime;	
	
}

void menuSetup() {

	fill(0);
	
	text(0,0, "2021 BY BEN HECK");
	
	text(2,2, "GO LEVEL");
	text(2,3, "EDITOR");

	menuSelect = 0;			//Starts with Option #1

	g = 0;					//Flag to exit menu when button pressed
	
	winX = 0;
	winY = 0;
	winXFine = 0;
	winYFine = 0; 	

	editMode = 0;
	sysState = menu;
	
	level = 1;
	
}

void mainMenu() {

	drawTitle();		//Draw the 4 line title graphic

	sendTiles(4);		//Then send 4 lines of text (from top of tilemap buffer)
	
	eventCounter++;

	if (eventCounter & 0x08) {
		arrows[0] = '<';
		arrows[1] = '>';		
	}
	else {
		arrows[0] = '[';
		arrows[1] = ']';		
	}
	
	tileMap[11][2] = arrows[0];
	tileMap[14][2] = arrows[1];

	switch(menuSelect) {
	
		case 0:
			tileMap[1][2] = arrows[1];
			tileMap[1][3] = 0;		
			if (level < 10) {
				tileMap[12][2] = '0';
				drawNumberMap(level, 13, 2);
			}
			else {
				drawNumberMap(level, 12, 2);	
			}
			if (dLeft()) {
				if (--level == 0) {
					level = 25;
				}
			}
			if (dRight()) {
				if (++level == 26) {
					level = 1;
				}
			}			
			if (g) {			//Start the game?
					eventCounter = 0;
					lives = 3;
					score = 0;
					debug = 0;
					levelStartSetup();					
			}
		break;

		case 1:
			tileMap[1][2] = 0;	
			tileMap[1][3] = arrows[1];
			/*
			if (dLeft()) {
				if (tonePitch > 0) {
					tonePitch -= 50;
					tone(tonePitch, 250, 10, 0);
				}
			}
			if (dRight()) {
				if (tonePitch < 1000) {
					tonePitch += 50;
					tone(tonePitch, 250, 10, 0);
				}
			}	
			drawNumberMap(tonePitch, 0, 0);
			
			*/
			if (g) {
				walls();
				editSetup(1);
			}
		break;
	
	}
	
	if (buttonA()) {
		g = 1;
	} 

	if (dUp()) { 		//Navigate menus up and down

		menuSelect--;

		if (menuSelect == 255) {	//Did we roll over below 0?
			menuSelect = 1;
		}

	}
	
	if (dDown()) {

		menuSelect++;

		if (menuSelect == 2) {
			menuSelect = 0;
		}

	}	

}

void editSetup(uint8_t resetCursor) {

	if (resetCursor) {
		pX = 1;
		pY = 1;
		winX = 0;
		winY = 0;
	}
	
	tileBackup = tileMap[pX][pY];
	resetAnimation();
	menuSelect = 0;
	editMode = 1;
	sysState = edit;
	ledAllOff();
		
}

void editLoop() {
	
	sendTiles(7);						//Draw the first 7 rows
	sendMenuLine();						//Draw the menu row #8

	eventCounter++;
	
	if (pressed(B_BUTTON)) {

		if (menuSelect == 0) {			//Did we just arrive? Set menu # and fix cursor tile
			tileMap[pX][pY] = tileBackup;
			menuSelect = 1;
		}
	
	  if (dUp()) { 		//Navigate menus up and down
		
		menuSelect--;		
		if (menuSelect < 1) {
			menuSelect = 10;
		}
		
		//beep.tone(beep.freq(100 + (menuSelect * 100)), 20);
		tone(200 + (menuSelect * 50), 200, 10, 0);

	  }
	  if (dDown()) {
		
		menuSelect++;		
		if (menuSelect > 10) {
			menuSelect = 1;
		}
		
		//beep.tone(beep.freq(100 + (menuSelect * 100)), 20);
		tone(200 + (menuSelect * 50), 200, 10, 0);
	  }	
	
		clrScratch();

		if (eventCounter & 0x08) {		//Blink the up/down arrow prompt on lower right		
			scratch[15] = 94;
		}
		else {		
			scratch[15] = 95;		
		}
			
		switch(menuSelect) {
		
			case 1:
			
				if (tilePlace == 0) {
					gg = 12;
				}
				else {
					gg = tilePlace - 1;	
				}

				for (int x = 2 ; x >= 0 ; x--) {
					scratch[x] = gg;
					if (--gg < 0) {
						gg = 12;
					}			
				}

				if (eventCounter & 0x08) {		//Blink the current tile		
					scratch[3] = '<';
					scratch[5] = '>';
				}
				else {		
					scratch[3] = '[';
					scratch[5] = ']';	
				}				
								
				scratch[4] = tilePlace;
				
				if (tilePlace == 12) {
					gg = 0;
				}
				else {
					gg = tilePlace + 1;	
				}		
				
				for (int x = 6 ; x < 9 ; x++) {
					scratch[x] = gg;
					if (++gg > 12) {
						gg = 0;
					}			
				}				
								
				textMenu(10, "TILE");	
			break;
			case 2:
				textMenu(3, "TEST LEVEL");
			break;
			case 3:
				textMenu(3, "SAVE EEPROM");
			break;
			case 4:
				textMenu(3, "LOAD EEPROM");
			break;						
			case 5:
				textMenu(3, "EXPORT UART");
			break;
			case 6:
				textMenu(6, "NEW FILE");
			break;
			case 7:			
				if (eventCounter & 0x08) {		//Blink the current tile		
					textMenu(0, "<    >   GEMS?");
				}
				else {		
					textMenu(0, "[    ]   GEMS?");
				}			
				drawNumberMenu(gemsNeeded, 1);
			break;
			case 8:
				if (eventCounter & 0x08) {		//Blink the current tile		
					textMenu(0, "<   >   SLIME?");
				}
				else {		
					textMenu(0, "[   ]   SLIME?");
				}	
				drawNumberMenu(slimeGrow, 1);
			break;				
			case 9:
				if (eventCounter & 0x08) {		//Blink the current tile		
					textMenu(0, "<  >  LOAD LVL");
				}
				else {		
					textMenu(0, "[  ]  LOAD LVL");
				}			
				drawNumberMenu(level, 1);
			break;
			case 10:
				//drawHexMenu(tileMap[pX][pY], 0);
				textMenu(10, "EXIT");
			break;		
		}
		
		if (dLeft()) {
		
			//beep.tone(beep.freq(2000), 10); // 1000Hz for 2 seconds
			tone(600, 100, 10, 0);
			switch(menuSelect) {
			
				case(1):
					tilePlace--;
					
					if (tilePlace < 0) {
						tilePlace = 12;
					}
				break;
				case(7):				
					if (gemsNeeded > 1) {
						gemsNeeded -= 10;
					}	
				break;
				case(8):
					if (slimeGrow > 10) {
						slimeGrow -= 10;
					}									
				break;				
				case(9):
					if (level > 1) {
						level--;
					}	
				break;	

				
			}

		}
		if (dRight()) {
			
			//beep.tone(beep.freq(2500), 10); // 1000Hz for 2 seconds
			tone(500, 100, 10, 0);
			switch(menuSelect) {
			
				case(1):
	
					tilePlace++;
					
					if (tilePlace > 12) {
						tilePlace = 0;
					}
												
				break;
				case(7):				
					if (gemsNeeded < 9999) {
						gemsNeeded += 10;
					}	
				break;
				case(8):
					
					if (slimeGrow < 250) {
						slimeGrow += 10;
					}									
				break;				
				case(9):
					if (level < 20) {
						level++;
					}				
				break;					
			}		
		}							
	}
	else {

		//Check if we released B with anything special selected (immediate action)

		if (menuSelect) {
			
			switch(menuSelect) {			
				case 2:						//Test level
					gameSetup();
					return;
				break;
				case 3:						//Save to EEPROM
					exportTarget = 0;
					ePoint = 16;			//EEPROM offset to start
					compressLevel();
					editSetup(0);
				break;
				case 4:						//Load from EEPROM
					exportTarget = 0;
					ePoint = 16;			//EEPROM offset to start
					decompressLevel();
					editSetup(1);
				break;		
				case 5:
					Serial.println("//Level X data:");
					itemsPerLine = 120;					//Start this 8 below the limit of 128 so the first 8 items (metadata) appear as their own line
					exportTarget =  1;
					compressLevel();	
					Serial.println("");
					Serial.print("//Data pointer:");
					Serial.println(totalCount - 1);
				break;
				case 6:
					walls();
				break;
				case 9:
					exportTarget = 1;
					gg = 0;					//Clear index pointer
					ePoint = 0;				//Clear ePoint pointer
					while (gg < level) {	//Find beginning of level memory in FLASH
						ePoint += levelSize[gg++];	//Add up ePoint with the lengths of all levels in front of the one we want to load
					}
					decompressLevel();
					editSetup(1);
				break;		
				case 10:
					menuSetup();
					return;
				break;
			}
			
			menuSelect = 0;			//Clear flag so we only check this once
			dPadBounce = 0;			//Clear d-pad bounce
			
		}
		
		if (eventCounter & 0x08) {		//Blink the current tile		
			tileMap[pX][pY] = tileBackup;			//Show original tile
			textMenu(0, "A=DROP>X< B=MENU");
		}
		else {		
			tileMap[pX][pY] = 92;			//Show crosshair
			textMenu(0, "A=DROP]X[ B=MENU");
		}
		
		scratch[7] = tilePlace;			//Draw the active tile

		if (buttonA()) {
			
			switch(tilePlace) {
			
				case man:
					if (manStartX) {		//If man start has already been placed, erase the old position and store new in RAM
						tileMap[manStartX][manStartY] = empty;
					}
					manStartX = pX;
					manStartY = pY;
				break;
				case door:
					if (doorX) {		//If door has already been placed, erase the old position and store new in RAM
						tileMap[doorX][doorY] = dirt1;
					}
					doorX = pX;
					doorY = pY;				
				break;
			}

			if (tileBackup != man && tileBackup !=  door) {	//Don't allow tiles to be dropped on the man start or door end tiles
				tileBackup = tilePlace;
				tileMap[pX][pY] = tileBackup;
			}
		
		}
		
		uint8_t moved = 0;
		
		if (moveRamp) {			
			moveRamp--;		
		}
		
		if (moveRamp == 0) {				//Limit movement speed with ramp up when held down
		
			if (pressed(RIGHT_BUTTON)) {

				if (pX < 46) {
					tileMap[pX][pY] = tileBackup;
					pX++;
					tileBackup = tileMap[pX][pY];
					moved = 1;
					
				}

			}
			if (pressed(LEFT_BUTTON)) {

				if (pX > 1) {
				
					tileMap[pX][pY] = tileBackup;
					pX--;
					tileBackup = tileMap[pX][pY];
					moved = 1;
				}		

			}
			if (pressed(UP_BUTTON)) { 

				if (pY > 1) {
				
					tileMap[pX][pY] = tileBackup;
					pY--;
					tileBackup = tileMap[pX][pY];
					moved = 1;
				
				}		
				
			}
			if (pressed(DOWN_BUTTON)) {

				if (pY < 30) {
				
					tileMap[pX][pY] = tileBackup;
					pY++;
					tileBackup = tileMap[pX][pY];
					moved = 1;
				
				}			

			}	

			if (moved) {
				dPadBounce &= 0xF0;			//Clear the debounce on A and B
				moveRamp = moveRampStart--;
				if (moveRampStart < 1) {
					moveRampStart = 1;
				}		
			}
			else {
				moveRampStart = 10;
				moveRamp = moveRampStart;
			}
		
		}
		
		if (pX < winX + 7 and winX > 0) {
			winX--;
		}

		if (pX > winX + 7 and winX < 32) {
			winX++;
		}

		if (pY < winY + 3 and winY > 0) {
			winY--;
		}

		if (pY > winY + 3 and winY < 25) {
			winY++;
		}		

	}
	
}

void levelStartSetup() {
	
	fill(0);							//Clear display

	text(4,0, "LANDFILL");
	drawNumberMap(level, 7, 1);

	//GAME OVER option here
	text(2,3, "MINERS LEFT");
	drawNumberMap(lives, 7, 4);	
	
	text(2,6, "SCRAP VALUE");
	tileMap[2][7] = '$';
	drawNumberMap(score, 4, 7);

	eventCounter = 120;				//2 seconds of this
	
	winX = 0;
	winY = 0;
	winXFine = 0;
	winYFine = 0; 	
	ledAllOff();
	
	sysState = levelStart;
	
}

void levelStartLoop() {

	sendTiles(8);		//Send the screen data

	if (--eventCounter == 0) {
		
		walls();				//Draw the walls
		
		exportTarget = 1;
		gg = 0;					//Clear index pointer
		ePoint = 0;				//Clear ePoint pointer
		while (gg < level) {	//Find beginning of level memory in FLASH
			ePoint += levelSize[gg++];	//Add up ePoint with the lengths of all levels in front of the one we want to load
		}
		decompressLevel();	
		gameSetup();
		
	}

}

void gameSetup() {

	pX = manStartX;
	pY = manStartY;
	
	clrScratch();
	
	for (int x = 16 ; x < 24 ; x++) {				//Erase man graphics so we can scroll him in later
		tiles[x] = 0;
	}	
				
	tileMap[pX][pY] = man;			//Place man (though it will start as blank since we just erased that memory)	
	manDir = 0;
	manFrame = 16;					//Use this to animate the door closing
	
	winXFine = 0;
	winYFine = 0; 	
	winX = doorX - 7;				//Center window on door
	winY = doorY - 3;

	for (int x = 0 ; x < 8 ; x++) {				//Erase door graphic
		tiles[24 + x] = 0;
	}	
	
	//Try to start the window with the door as centered as possible (unless it's on an edge)
	
	if (winX < 0) {
		winX = 0;
	}
	
	if (winX > 32) {
		winX = 32;
	}
	
	if (winY < 0) {
		winY = 0;
	}
	
	if (winY > 24) {
		winY = 24;
	}

	eventCounter = 0;
	gemsCollected = 0;
	red = gemsNeeded;
	//ledAllOff();
	
	playerState = 0;			//Player not spawned
	screenTimer = 0;			//Timer to move camera
	aniPointer = 0;
	
	sysState = game;
	
}

void gameLoop() {			//The main game loop

	if (debug != 0xFF) {	//Not paused? Run logic

		if (flash) {
			PORTB &= 0x1F;				//White LED flash		
			if (--flash == 0) {
				
				if (gemsCollected >= gemsNeeded) {
					PORTB &= 0x1F;			//Switch to green right away
					PORTB |= 0x60;			//Other colors off
					colorFrame = 0;			
				}
				else {
					ledAllOff();
				}			

			}
			
		}
		else {

			if (gemsCollected >= gemsNeeded) {
				if (++colorFrame == slimeGrow) {	//Turn off the LED's when value reached
					PORTB ^= (1 << 7);				//Toggle green
					//PORTB |= (1 << 6);
					colorFrame = 0;
				}				
			}
			else {
				if (++colorFrame == red) {	//Turn off the LED's when value reached
					PORTB ^= (1 << 6);				//Toggle red
					colorFrame = 0;
				}				
			}		
		}

	  switch(eventCounter++) {      //We divide up frame time by 8

		case 1:						//Player movement state
		  moveGuy();
		break;
		
		case 2:						//World object animation state
		
			for (int x = 0 ; x < 56 ; x++) {				//Copy 40 bytes from flash pointer to tile RAM
				tiles[48 + x] = pgm_read_byte_near(aniTiles + aniPointer + x);
			}
			aniPointer += 56;
			
			if (aniPointer == 224) { //192) {
				aniPointer = 0;
			}
		
		break;
		
		case 3:						//Man animation state
		
			if (manDir) {

				uint8_t manPointer;

				switch(manDir) {
				
					case 1:	//Up?
					
					if (manFrame == 3) {
							manPointer = 40;
					}
					else {
						manPointer = 32 + (manFrame << 3);
					}
				
					for (int x = 0 ; x < 8 ; x++) {				//Man just standing there
						tiles[16 + x] = pgm_read_byte_near(mani + manPointer + x);
					}
		
					break;
					case 2:	//Down?
					
					if (manFrame == 3) {
							manPointer = 64;
					}
					else {
						manPointer = 56 + (manFrame << 3);
					}
				
					for (int x = 0 ; x < 8 ; x++) {				//Man just standing there
						tiles[16 + x] = pgm_read_byte_near(mani + manPointer + x);
					}				
					
					break;			
					case 3:	//Left?
					
					if (manFrame == 3) {
							manPointer = 16;
					}
					else {
						manPointer = 8 + (manFrame << 3);
					}
				
					for (int x = 0 ; x < 8 ; x++) {				//Man just standing there
						tiles[16 + x] = pgm_read_byte_near(mani + manPointer + (7 - x));		//Mirror the image as we load it in
					}				
					
					break;		
					case 4:	//Right?
					
					if (manFrame == 3) {
							manPointer = 16;
					}
					else {
						manPointer = 8 + (manFrame << 3);
					}
				
					for (int x = 0 ; x < 8 ; x++) {				//Man just standing there
						tiles[16 + x] = pgm_read_byte_near(mani + manPointer + x);
					}					
					
					break;		
					case 5:	//Pushing left?
					
					if (manFrame > 2) {
						manFrame = 0;
					}
					
					manPointer = 80 + (manFrame << 3);

					for (int x = 0 ; x < 8 ; x++) {				//Man just standing there
						tiles[16 + x] = pgm_read_byte_near(mani + manPointer + (7 - x));		//Mirror the image as we load it in
					}	

		
					
					break;		
					case 6:	//Pushing right?
					
					if (manFrame > 2) {
						manFrame = 0;
					}				

					manPointer = 80 + (manFrame << 3);

					for (int x = 0 ; x < 8 ; x++) {				//Man just standing there
						tiles[16 + x] = pgm_read_byte_near(mani + manPointer + x);
					}					
					
					break;				
				
				}
				
				if (++manFrame == 4) {
					manFrame = 0;
				}
			
			}
			else {

				switch(playerState) {
				
					case 2:
						for (int x = 0 ; x < 8 ; x++) {				//Man emerges from ground (bitshifting)
							tiles[16 + x] = pgm_read_byte_near(mani + x) << screenTimer;
						}	

						if (--screenTimer == 0) {					//Done emerging? Give player control
							playerState = 3;
							manFrame = 0;
						}
				
					break;
			
					case 3:

						for (int x = 0 ; x < 8 ; x++) {				//Man in active gameplay
							tiles[16 + x] = pgm_read_byte_near(mani + x);
						}					
					
					break;
		
				}
			
			}

		break;
		
		case 4:						//Door animation state
		
			if (playerState == 0) {

				g = 8;
				
				if (manFrame == 4) { //Showing the door location? Animate it closing
							
					g = 7;
					
					manFrame = 0;
				
				}	
				
				if (manFrame > 6) { //Showing the door location? Animate it closing
							
					g = manFrame;
					
					manFrame -= 4;
				
				}
				
				for (int x = 0 ; x < 8 ; x++) {		//Update door graphic in RAM
					tiles[24 + x] = pgm_read_byte_near(doori + g + x);
				}
				
			}
			
			if (gemsCollected >= gemsNeeded and playerState != 5) {		//Ready to exit? (but player hasn't exited yet)
				
				g = (screenTimer++ & 1) << 3;		//Blink the graphic

				for (int x = 0 ; x < 8 ; x++) {		//Update door graphic in RAM
					tiles[24 + x] = pgm_read_byte_near(doori + g + x);
				}					

			}
			
		break;

		case 7:						//Do gravity physics and enemy movement
		  physics();
		  eventCounter = 0;
		break;
	 
	  }
	 

		if (playerState == 0) {				//Showing door?

			if (screenTimer++ == 40) {
				playerState = 1;
				tone(1020, 250, 10, 0); 			
			}
		
		}
		else {

			scrollFlag = 0;				//Flag that's set if scrolling happens

			if (scrollLeft) {
				scrollLeft--;
				scrollFlag = 1;
				if (--winXFine < 0) {
				  winXFine += 8;
				  winX--;
				}
			}

			if (scrollRight) {
				scrollRight--;
				scrollFlag = 1;
				if (++winXFine > 7) {
				  winXFine -= 8;
				  winX++;
				}
			}

			if (scrollUp) {
				scrollUp--;
				scrollFlag = 1;
				if (--winYFine < 0) {
				  winYFine += 8;
				  winY--;
				}
			}

			if (scrollDown) {
				scrollDown--;
				scrollFlag = 1;
				if (++winYFine > 7) {
				  winYFine -= 8;
				  winY++;
				}
			}

			if (scrollFlag == 0 and playerState == 1) { //Scrolling map to reveal player, and scrolling is complete?

				manFrame = 0;
				playerState = 2;				//Player will now appear from the ground (rise from a grave?)
				screenTimer = 8;				//Used as a bit shifter

			}

		}

	}

	clrScratch();

	switch(debug) {
		case 0:
			scrollTiles(8);
		break;
		
		case 1:
			drawNumberMenu(gemsCollected, 0);
			scratch[cursorX++] = '/';
			drawNumberMenu(gemsNeeded, cursorX);
			scratch[cursorX++] = ' ';
			scratch[cursorX++] = '%';
			scratch[cursorX++] = '&';		
			drawNumberMenu(gemsTotal, cursorX);
			//drawNumberMenu(cpuLoad(), 11);
			scratch[14] = '*';
			drawNumberMenu(lives, 15);
			scrollTiles(7);
			sendMenuLine();		
		break;
		
		case 2:
			textMenu(0, "SCORE");
			drawNumberMenu(score, 6);
			scrollTiles(7);
			sendMenuLine();		
		break;
		
		case 0xFF:
			textMenu(5, "PAUSED");
			scrollTiles(7);
			sendMenuLine();		
		break;		
	}

	//Only do this if slime exists
	slimeExpand++;

	if (buttonA()) {				//Toggle the info panel
		if (++debug == 3) {
			debug = 0;
		}
	}  

	if (buttonB()) {
	
		if (editMode) {								//Abort test and back to editing
			stripAttributes();
			tileMap[pX][pY] = 0;					//Erase current player position	
			tileMap[manStartX][manStartY] = man;	//Redraw man in original position
			editSetup(1);
		
			//tileMap[manStartX][manStartY] = man;
			//sysState = edit;			
		}
		else {			
			switch(debug) {
				case 0:
					if (playerState == 3) {
						killGuy();		//Give up!
					}					
				break;				
				case 1:
				case 2:
					debug = 0xFF;
				break;
				
				case 0xFF:
					debug = 1;
				break;
			}			
		}		
	}

	if (playerState == 4) {		//Player exploded?

		if (--screenTimer == 0) {
			if (editMode) {
				stripAttributes();
				tileMap[pX][pY] = 0;					//Erase current player position	
				tileMap[manStartX][manStartY] = man;	//Redraw man in original position
				editSetup(1);	
			}
			else {			
				if (--lives) {
					levelStartSetup();
				}
				else {
					menuSetup();			//Game ovah
				}				
			}
		}
				
	}
	
	if (playerState == 5) {		//Player escaped?

		tileMap[doorX][doorY] = door;	//Redraw door

		if (--screenTimer == 0) { 
			level++;
			levelStartSetup();
		}
					
	}	

}

void moveGuy() {

	if (playerState == 0) {				//Animation of door closing? Don't test for scroll condition
		return;
	}

	//See if window needs to be scrolled to catch up to our guy
	if (pX < winX + 6 and winX > 0) {
		scrollLeft = 8;
	}

	if (pX > winX + 10 and winX < 32) {
		scrollRight = 8;
	}

	if (pY < winY + 3 and winY > 0) {
		scrollUp = 8;
	}

	if (pY > winY + 4 and winY < 24) {
		scrollDown = 8;
	}

	//Get input and move guy  
  
	if (playerState == 3) {				//Is player allowed to move?

	  if (pressed(RIGHT_BUTTON)) {

		if (pX < 46 and eat(pX+1, pY, 4)) {  
		  //tileMap[++pX][pY] = man;
		  manDir = 4;
		  return;    
		}
		if (manDir == 6) {
			return;
		}
	  }
	  if (pressed(LEFT_BUTTON)) {

		if (pX > 1 and eat(pX-1, pY, 0)) {
		  //tileMap[--pX][pY] = man;
		  manDir = 3;
		  return;
		}
		if (manDir == 5) {
			return;
		}		
	  }

	  if (pressed(UP_BUTTON)) { 
		
		if (pY > 1 and eat(pX, pY-1, 2)) {
		  //tileMap[pX][--pY] = man;
		  manDir = 1;
		  return;
		}   
	  }
	  if (pressed(DOWN_BUTTON)) {
		
		if (pY < 30 and eat(pX, pY+1, 6)) {
		  //tileMap[pX][++pY] = man;
		  manDir = 2;
		  return;
		}   
	  }

	manDir = 0;			//Not moving? Reset man animation
	manFrame = 0;
	push = 0;			//Also reset push power

	}

}

int killGuy() {

	explosion(pX, pY, empty);
	playerState = 4;
	screenTimer = 150;			//2.5 seconds of aftermath!
	return 1;

}	

int eat(uint8_t x, uint8_t y, uint8_t dir) {            //When moving into a tile this processes what's there. Includes escape door

	uint8_t tile = tileMap[x][y] & 0x0F;	//Mask off any control bits

	uint8_t canEat = 1;						//By default assume we can eat this... unless we cant!

	switch(tile) {
		
		case empty:
		case gas:
		
		break;
		
		case dirt1:
			score++;
			//beep.tone(beep.freq(dirtSound), 5); // 1000Hz for 2 seconds
			tone(dirtSound + 900, 50, 2, 0);			
			dirtSound += 39;
			if (dirtSound > 123) {
				dirtSound = 0;
			}		
		break;
		
		case jem:
			score += 100;
			//beep.tone(beep.freq(2000), 15); 	// 1000Hz for 2 seconds
			tone(250, 300, 10, 0);
			gemsCollected++;					//Put "found them all" check here?
			flash = 6;
			red -= 1;
			
			if (gemsCollected == gemsNeeded) {
				slimeGrow = 64;		
			}	
			
			if (gemsCollected > gemsNeeded and slimeGrow > 1) {
				slimeGrow--;		
			}		
		break;
		
		case ball:;
			canEat = 0;									//Assume we can't move it (most likely state, saves code)
			if (dir == 0) {								//Trying to push left?
				if (emptyOrGas(x - 1, y)) {				//Is area to left of rock empty?
					if (++push > pushPower) {
						push = 0;
						tileMap[x-1][y] = ball;			//Move ball and return that player can move left
						//tileMap[x][y] = empty;
						manDir = 0;
						canEat = 1;
					}
					else {
						manDir = 5;						//Set man move state to PUSHING LEFT
					}
				}
			}
			
			if (dir == 4) {								//Trying to push right?
				if (emptyOrGas(x + 1, y)) {				//Is area to right of rock empty?
					if (++push > pushPower) {
						push = 0;
						tileMap[x+1][y] = ball;			//Move ball and return that player can move right
						//tileMap[x][y] = empty;
						manDir = 0;
						canEat = 1;
					}
					else {
						manDir = 6;						//Set man move state to PUSHING RIGHT
					}			
				}		
			}				
		break;

		case door:		
			if (gemsCollected >= gemsNeeded) {

				if (editMode) {
					menuSelect = 0;
					stripAttributes();
					tileMap[pX][pY] = 0;
					tileMap[manStartX][manStartY] = man;
					winX = 0;
					winY = 0;
					sysState = edit;
					//return 1;	  				
				}
				else {
					
					for (int x = 0 ; x < 8 ; x++) {		//Update door graphic in RAM
						tiles[24 + x] = pgm_read_byte_near(doori + 8 + x);
					}	
					
					playerState = 5;			//Set state to escaped! 
					screenTimer = 120;
					score += 50000;
					//return 1;					//Allow man to move into door (he will get erased but we'll have to re-draw door)

				}
			}
			else {
				canEat = 0;						//No soup for you!
			}
		break;
		
		default:
			canEat = 0;
		break;
		
		
	}

	if (canEat) {				//Did we eat something?
		tileMap[pX][pY] = 0;	//Erase where man was
		pX = x;					//Update man pos to this spot
		pY = y;		
		tileMap[pX][pY] = man;	//And put him where the thing he just ate was
	}
	
	return canEat;
	

/*
  if (tile == 0) {     //Empty tile
    return 1;
  }
  if (tile == 1) {      //Must be dirt    
	score++;
	beep.tone(beep.freq(dirtSound), 5); // 1000Hz for 2 seconds    
	dirtSound += 100;
	if (dirtSound > 500) {
		dirtSound = 200;
	}
	return 1;
  }
  if (tile == jem) {   //A gem?
	score += 100;
	beep.tone(beep.freq(2000), 15); 	// 1000Hz for 2 seconds
	gemsCollected++;					//Put "found them all" check here?
	flash = 6;
	red -= 1;
	
	if (gemsCollected == gemsNeeded) {
		slimeGrow = 64;		
	}	
	
	if (gemsCollected > gemsNeeded and slimeGrow > 1) {
		slimeGrow--;		
	}
	
    return 1;
  }
  if (tile == ball) {		//A ball rock?

	if (dir == 0) {								//Trying to push left?
		if (tileMap[x-1][y] == 0) {				//Is area to left of rock empty?
			if (++push > pushPower) {
				push = 0;
				tileMap[x-1][y] = ball;			//Move ball and return that player can move left
				tileMap[x][y] = empty;
				manDir = 0;
				return 1;
			}
			else {
				manDir = 5;
			}
		}
	}
	
	if (dir == 4) {								//Trying to push right?
		if (tileMap[x+1][y] == 0) {				//Is area to right of rock empty?
			if (++push > pushPower) {
				push = 0;
				tileMap[x+1][y] = ball;			//Move ball and return that player can move right
				tileMap[x][y] = empty;
				manDir = 0;
				return 1;
			}
			else {
				manDir = 6;
			}			
		}		
	}

	  
  }

  if (tile == door and gemsCollected >= gemsNeeded) {

	if (editMode) {
		menuSelect = 0;
		stripAttributes();
		tileMap[pX][pY] = 0;
		tileMap[manStartX][manStartY] = man;
		winX = 0;
		winY = 0;
		sysState = edit;
		return 1;	  				
	}
	else {
		
		for (int x = 0 ; x < 8 ; x++) {		//Update door graphic in RAM
			tiles[24 + x] = pgm_read_byte_near(doori + 8 + x);
		}	
		
		playerState = 5;			//Set state to escaped! 
		screenTimer = 120;
		score += 50000;
		return 1;					//Allow man to move into door (he will get erased but we'll have to re-draw door)
	
	}


  }
    
  return 0;       //Else you can't move
*/ 

}

void setScanXY(uint8_t x, uint8_t y) {

	scanX = x;
	scanY = y;
	
}

int emptyOrGas(uint8_t x, uint8_t y) {
	
	if (tileMap[x][y] == 0 || tileMap[x][y] == gas) {
		return 1;
	}
	
	return 0;

}

void physics() {

	uint8_t xt;											//Temp target value
	uint8_t yt;

  for (int x = 1 ; x < 47 ; x++) {        				//Don't check the physics of the outer walls (sub 1 on all sides)

    for (int y = 30 ; y > 0 ; y--) {

      uint8_t object = tileMap[x][y];					//Get the value of this tile along with any flags

	  setScanXY(x, y);

      switch(object & 0x0F) {          					 //Mask off the top 4 control bits of current tile to make decisions
		case(jar):
			if (object & falling) {						//Is this a falling jar? See if something is under it				
				if (tileMap[x][y+1] && tileMap[x][y+1] != gas) { 	//If a falling jar hits anything, it breaks into slime
					explosion(x, y, slime);
					break;
				}		
			}	
		case(jem):                      				//Jems and balls do same stuff
        case(ball):                     				//Ball or Jem?
          switch(tileMap[x][y+1] & 0x0F) {     			//Decide what to do based off what's under the ball. AND out the upper flags (such as falling or movement patterns)		
			case(gas):
			case(empty):                  				//Nothing? (or gas) Object falls
              tileMap[x][y] = 0;
              tileMap[x][y + 1] = object | falling;     //Erase ball and move it one space down. Add the FALLING bit to object
            break;
			case(jar):									//Was it falling and hit a jar? Jar breaks and releases deadly SLIME!
				if (object & falling) {					//The item must be falling for this to happen. If it spawns simply sitting above jar no explosion
					explosion(x, y + 1, slime);
				}
			break;
			case(man):									//Was it falling and hit a jar? Jar breaks and releases deadly SLIME!
				if (object & falling) {					//The item must be falling for this to happen. If it spawns simply sitting above jar no explosion
					killGuy();
				}
			break;			
			case(seeker):
			case(crawler):
            case(monster):                				//Did we land on a monster? Blow it up! (explosion centered on monster)
              explosion(x, y + 1, jem);
			  score += 200;
            break;
            case(jem):                    				//Roll off jems and balls same way
            case(ball):                   				//If possible balls roll off balls	
				if (object & falling) {						//Is this a falling jar? See if something is under it				
					tone(920, 50, 0, 0);				
				}			
				tileMap[x][y] &= 0x0F;					//Mask off falling bit. If item rolls left or right this may get re-enabled	
              if (emptyOrGas(x - 1, y) and emptyOrGas(x - 1, y - 1) and emptyOrGas(x + 1, y) and emptyOrGas(x + 1, y + 1)) {		//Ball can roll either way?
                if (rollToggle & 1) {
                    tileMap[x][y] = 0;  
                    tileMap[x+1][y] = object;                                     //Roll ball right
                    x++;                                                        //Skip checking the next tile since we just put a ball there (checks from left to right)
                    rollToggle++;
                    break;        
                }
                else {
                    tileMap[x][y] = 0;  
                    tileMap[x-1][y] = object;                                     //Roll ball left
                    rollToggle++;
                    break;            
                }     
              }                                                                 //If we make it this far it means at least one side of the ball is blocked
              if (emptyOrGas(x - 1, y) and emptyOrGas(x - 1, y + 1)) {            //Space to the left and down? Roll left
                tileMap[x][y] = 0; 
                tileMap[x-1][y] = object;
                break;
              }
              if (emptyOrGas(x + 1, y) and emptyOrGas(x + 1, y + 1)) {            //Space to the right? Roll right.
                tileMap[x][y] = 0; 
                tileMap[x+1][y] = object;
                x++;                                                            //Skip checking the next tile since we just put a ball there (checks from left to right)
                break;
              }
			break;
			default:									//Landed inert on dirt or wall?		
				if (object & falling) {						//Is this a falling jar? See if something is under it				
					tone(1020, 50, 0, 0);				
				}
				tileMap[x][y] &= 0x0F;					//Mask off falling bit	(if any)			
			break;
            }

        break;

		case(slime):
			canSlimeGrow(x, y);		
		break;
		
		case(gas):
          if (object & dontMove) {           //Was this gas expanded up in a previous lower row scan?
            tileMap[x][y] &= 0x7F;           //Remove the bit and BREAK out to move onto next tile
          }
          else {                             //Normal operation check for available movement		
			canGasGrow(x, y);
		  }
		break;	
		
		case(seeker):
			if (object & dontMove) {          //Was this monster moved up in a previous lower row scan?
				tileMap[x][y] &= 0x7F;                 //Remove the bit and BREAK out to move onto next tile
			}
			else {
				if (radialCheck(x, y, slime)) {
					explosion(x, y, jem);
					break;
				}	
				if (radialCheck(x, y, man)) {
					if (killGuy()) {				//If player can be killed, abort all other checks
						break;
					}
				}
				
				if (pX < x && emptyOrGas(x - 1, y)) {		//Is the player to the left of seeker, and a slot to left is open?
					tileMap[x][y] = 0;							//Clear old tile
					tileMap[x - 1][y] = seeker;
				}
				else if (pX > x && emptyOrGas(x + 1, y)) {		//Is the player to the right of seeker, and a slot to right is open?
					tileMap[x][y] = 0;
					tileMap[x + 1][y] = seeker;
					x++;											//Since we moved to the right skip the check of the tile we just filled
				}	
				else if (pY < y && emptyOrGas(x, y - 1)) {		//Is the player above seeker and space open?
					tileMap[x][y] = 0;
					tileMap[x][y - 1] = seeker | dontMove;			//Move it and set flag skip next scan (so it doesn't move twice)
				}
				else if (pY > y && emptyOrGas(x, y + 1)) {		//Is the player below seeker and space open?
					tileMap[x][y] = 0;				
					tileMap[x][y +1] = seeker;
				}	
				
			}
		break;
        case(crawler):
		
			if (radialCheck(x, y, slime)) {
				explosion(x, y, jem);
				break;
			}
			if (radialCheck(x, y, man)) {
				if (killGuy()) {				//If player can be killed, abort all other checks
					break;
				}
			}
	
          if (object & dontMove) {          //Was this monster moved up in a previous lower row scan?
            tileMap[x][y] &= 0x7F;                 //Remove the bit and BREAK out to move onto next tile
          }
          else {                             //Normal operation check for available movement
           switch(object & 0xF0) {           //Mask off everything but the 2 bit direction indicator (UDLR)

            case(moveUp):                    //Moving up along a wall to the right?
              if (emptyOrGas(x + 1, y)) {    //A gap to our right?
                tileMap[x][y] = 0;
                tileMap[x+1][y] = crawler | moveRight;   //Move crawler to right and skip next tile check
                x++;
              }
              else {                        //OK solid object to right. What about up?
                if (emptyOrGas(x, y - 1)) { //Gap above us?
                    tileMap[x][y] = 0;
					tileMap[x][y-1] = object | dontMove;	//Move into it! (and skip next scan)
                }
				else {
					tileMap[x][y] = crawler | moveLeft; //Solid above? Turn left
				}
              }		
            break;
            case(moveLeft):                  //Moving left with a wall above?
              if (emptyOrGas(x, y - 1)) {    //A gap above us?
                tileMap[x][y] = 0;
                tileMap[x][y-1] = crawler | moveUp | dontMove;   //Move crawler up and change direction
              }
              else {                        //OK solid object above. What about left?
                if (emptyOrGas(x - 1, y)) { //Gap to left?
                    tileMap[x][y] = 0;
					tileMap[x-1][y] = object;	//Move into it! (no change of control bits)
                }
				else {
					tileMap[x][y] = crawler | moveDown; //Solid to left? Turn down
				}
              }
            break;
            case(moveDown):                  //Moving down with a wall to left?
              if (emptyOrGas(x - 1, y)) {    //A gap to our left?
                tileMap[x][y] = 0;
                tileMap[x-1][y] = crawler | moveLeft;   //Move crawler left and change direction
              }
              else {                        //OK solid object to left. What about down?
                if (emptyOrGas(x, y + 1)) { //Gap below us?
                    tileMap[x][y] = 0;
					tileMap[x][y + 1] = object;	//Move into it! (no change of control bits)
                }
				else {
					tileMap[x][y] = crawler | moveRight; //Solid below us? Turn right
				}
              }
            break;
            case(moveRight):                  //Moving right with a wall below?
              if (emptyOrGas(x, y + 1)) {    //A gap below us?
                tileMap[x][y] = 0;
                tileMap[x][y+1] = crawler| moveDown;   //Move crawler down and change direction
              }
              else {                        //OK solid object below. What about right?
                if (emptyOrGas(x + 1, y)) { //Gap to right?
                    tileMap[x][y] = 0;
					tileMap[x+1][y] = object;	//Move into it! (no change of control bits)
					x++;
                }
				else {
					tileMap[x][y] = crawler | moveUp; //Solid to left? Turn up
				}
              }
            break;			
		   }
			
		}
        break;

        case(monster):
		
			if (radialCheck(x, y, slime)) {
				explosion(x, y, jem);
				break;
			}
			
			if (radialCheck(x, y, man)) {
				if (killGuy()) {				//If player can be killed, abort all other checks
					break;
				}
			}			
		
          if (object & dontMove) {          //Was this monster moved up in a previous lower row scan?
            tileMap[x][y] &= 0x7F;                 //Remove the bit and BREAK out to move onto next tile
          }
          else {                             //Normal operation check for available movement
           switch(object & 0xF0) {           //Mask off everything but the 2 bit direction indicator (UDLR)

            case(moveUp):                    //Up?
              if (tileMap[x][y-1] != 0) {    //Can't go up?
                tileMap[x][y] = monster | (random(4) << 4);
              }
              else {                        //Else move up
                tileMap[x][y] = 0;
                tileMap[x][y-1] = object | dontMove;            //Add the Don't Move bit so this object won't get moved when the row above is scanned
              }
            break;
            case(moveDown):                  //Down?
              if (tileMap[x][y+1] != 0) {   //Can't go down?
                tileMap[x][y] = monster | (random(4) << 4);
              }
              else {                        //Else move down
                tileMap[x][y] = 0;
                tileMap[x][y+1] = object;
              }
            break;
            case(moveLeft):                 //Left?
              if (tileMap[x-1][y] != 0) {   //Can't go left?
                object &= 0x0F;
                tileMap[x][y] = monster | (random(4) << 4);
              }
              else {                        //Else move left
                tileMap[x][y] = 0;
                tileMap[x-1][y] = object;
              }
            break;
            case(moveRight):                //Right?
              if (tileMap[x+1][y] != 0) {   //Can't go right?
                object &= 0x0F;
                tileMap[x][y] = monster | (random(4) << 4);
              }
              else {                        //Else move right
                tileMap[x][y] = 0;
                tileMap[x+1][y] = object;
                x++;						//Increment X pointer so we don't immediately move it again on the next column check
              }
            break;
			}
          }           
        break;
        case(exp1):       					//First frame of explosion?
          tileMap[x][y]++;      			//Advance to next frame
		  //tone(350, 15, 9, 0);
        break;
        case(exp2):       					//Second frame of explosion?
          tileMap[x][y]++;     				 //Advance to next frame
		  //tone(200, 15, 9, 0);
        break;
        case(exp3):       					//Final frame of explosion?         
          tileMap[x][y] = object >> 4;    	//Upper nibble says what to leave behind. Can also be nothing
		  //tone(100, 95, 9, -1);
        break;       
        default:
        break;     
      } 
    }
  }
  	  
  
}

uint8_t dUp() {

	if (pressed(UP_BUTTON)) {		//Pressed? See if bit is set


		if (dPadBounce & upBit) {		//Bit still set? No dice
			return 0;
		}
		dPadBounce |= upBit;			//Bit clear? Set it
		return 1;						//and return status		

	}
	else {
		dPadBounce &= ~upBit;			//Button not pressed? Clear the bit, allowing a retrigger
		return 0;
	}

}

uint8_t dDown() {

	if (pressed(DOWN_BUTTON)) {		//Pressed? See if bit is set


		if (dPadBounce & downBit) {		//Bit still set? No dice
			return 0;
		}
		dPadBounce |= downBit;			//Bit clear? Set it
		return 1;						//and return status

	}
	else {
		dPadBounce &= ~downBit;			//Button not pressed? Clear the bit, allowing a retrigger
		return 0;
	}

}

uint8_t dLeft() {

	if (pressed(LEFT_BUTTON)) {		//Pressed? See if bit is set


		if (dPadBounce & leftBit) {		//Bit still set? No dice
			return 0;
		}
		dPadBounce |= leftBit;			//Bit clear? Set it
		return 1;						//and return status


	}
	else {
		dPadBounce &= ~leftBit;			//Button not pressed? Clear the bit, allowing a retrigger
	}

}

uint8_t dRight() {

	if (pressed(RIGHT_BUTTON)) {		//Pressed? See if bit is set


		if (dPadBounce & rightBit) {		//Bit still set? No dice
			return 0;
		}
		dPadBounce |= rightBit;			//Bit clear? Set it
		return 1;						//and return status


	}
	else {
		dPadBounce &= ~rightBit;			//Button not pressed? Clear the bit, allowing a retrigger
	}

}

uint8_t buttonA() {

	if (pressed(A_BUTTON)) {		//Pressed? See if bit is set

		if (dPadBounce & aBit) {		//Bit still set? No dice
			return 0;
		}
		dPadBounce |= aBit;			//Bit clear? Set it
		return 1;						//and return status

	}
	else {
		dPadBounce &= ~aBit;			//Button not pressed? Clear the bit, allowing a retrigger
	}
	
	return 0;

}

uint8_t buttonB() {

	if (pressed(B_BUTTON)) {		//Pressed? See if bit is set	

		if (dPadBounce & bBit) {		//Bit still set? No dice
			return 0;
		}
		dPadBounce |= bBit;			//Bit clear? Set it
		return 1;						//and return status

	}
	else {
		dPadBounce &= ~bBit;			//Button not pressed? Clear the bit, allowing a retrigger
	}
	
	return 0;

}

void ledAllOff() {
	
	PORTB |= 0xE0;			//All colors off
	colorFrame = 0;		
				
}	

void stripAttributes() {					//Removes the top 4 attribute bits from all tiles on the map
	
	for (winY = 1 ; winY < 30 ; winY++) {
		
		for (winX = 1 ; winX < 47 ; winX++) {
			
			tileMap[winX][winY] &= 0x0F;
		
		}	
	}
	
}

void compressLevel() {			//RLE compresses a level using upper nibble for tile # and lower nibble for # of reps (up to 15) Sends to EEPROM or UART

	tileMap[pX][pY] = tileBackup;

	eeByte = tileMap[1][1];							//Get first tile
	gg = 0;												//Clear the count
	
	totalCount = 0;
	
	exportByte(gemsNeeded & 0x00FF);		//Low byte of value (little endian)
	exportByte(gemsNeeded >> 8);			//High byte of value
	exportByte(slimeGrow);					//How fast the slime grows
	exportByte(0x00);						//Reserved
	exportByte(0x00);						//Reserved	
	exportByte(0x00);						//Reserved
	exportByte(0x00);						//Reserved	
	exportByte(0x00);						//Reserved	
	
	int reloadFlag = 0;
	
	for (int y = 1 ; y < 31 ; y++) {
		
		for (int x = 1 ; x < 47 ; x++) {
			
			if (reloadFlag) {
				eeByte = tileMap[x][y];			//Get current tile (start of new block)
				reloadFlag = 0;
			}

			if (tileMap[x][y] == eeByte) {			//Does this tile match?		
				if (++gg == 15)	{							//Increment count (this also sets the first count of the first tile)
					exportByte(eeByte << 4 | gg);							//If we reach 15 (nibble limit) store the block
					reloadFlag = 1;
					gg = 0;
				}								
			}
			else {
				exportByte(eeByte << 4 | gg);								//Found different tile? Store previous block
				eeByte = tileMap[x][y];			//Get current tile (start of new block)
				gg = 1;										//And count that there's at least 1			
			}
		
		}	
	}

	totalCount++;
	exportByte(eeByte << 4 | gg);
	
	menuSelect = 0;

}

void decompressLevel() {		//Decompresses level data from EEPROM or FLASH

	gemsNeeded = 0;
	gemsTotal = 0;

	clrScratch();

	tileMap[pX][pY] = tileBackup;

	gemsNeeded = importByte();
	gemsNeeded |= importByte();
	slimeGrow = importByte();
	
	importByte();				//Reserved
	importByte();
	importByte();	
	importByte();
	importByte();

	eeByte = importByte();							//Get first tile
	uint8_t tilesToGo = eeByte & 0x0F;				//Get number of RLE tiles (lower nibble)
	eeByte >>= 4;									//Bitshift over the upper nibble. This is the tile type

	for (int y = 1 ; y < 31 ; y++) {
		
		for (int x = 1 ; x < 47 ; x++) {

			tileMap[x][y] = eeByte;				//Place current tile on map
			
			if (eeByte == man) {						//Did we place a man? Set its position
				manStartX = x;
				manStartY = y;
			}
			if (eeByte == door) {						//Did we place a door? Set its position
				doorX = x;
				doorY = y;
			}	
			if (eeByte == jem) {						//Count total gems, bonus if you CATCH EM ALL!
				gemsTotal++;
			}
			if (--tilesToGo == 0) {							//No more copies of this tile?
				eeByte = importByte();					//Get next tile
				tilesToGo = eeByte & 0x0F;						//and next count
				eeByte >>= 4;								
			}

		}	
	}

	//x = 0;
	//y = 0;
	
	pX = manStartX;
	pY = manStartY;
	
	winX = 0;
	winY = 0;
	
	menuSelect = 0;

}

uint8_t importByte() {		//Get a byte either from EEPROM or program flash (built in levels)
	
	if (exportTarget == 0) {				//Reading from EEPROM?		
		return EEPROM.read(ePoint++);		//Read byte and increment pointer		
	}
	else {									//Reading from program flash memory?
		return pgm_read_byte_near(levelData + ePoint++);
	}	

}

void exportByte(uint8_t theByte) {
	
	if (exportTarget == 0) {		
		if (ePoint & 0x08) {
			PORTB &= ~(1 << 6);				//Blink LED	
		}
		EEPROM.write(ePoint++, theByte);			//Upper nibble is tile #, lower nibble is # of tiles
		PORTB |= (1 << 6);					//Turn off LED
	}
	else {
		Serial.print("0x");
		Serial.print(theByte, HEX);
		Serial.print(", ");
	
		if (++itemsPerLine == 128) {			//After 128 entries, create a new line							
			Serial.println("");					//New line
			itemsPerLine = 0;
		}
	
	}	

	totalCount++;
	
}

void explosion(uint8_t x, uint8_t y, uint8_t result) {

  result <<= 4;         //Shift this to left. It sets what will remain after explosion is done

  tileMap[x][y] = exp1 | result;		//Explosion epicenter

  int changes = 1;						//Count how many tiles were changed by the explosion. Starts with 1 (the epicenter)

  if (isValid(x - 1, y)) {
    tileMap[x-1][y] = exp1 | result;
	changes++;
  }
  if (isValid(x - 1, y - 1)) {
    tileMap[x-1][y-1] = exp1 | result;
	changes++;
  }
  if (isValid(x , y - 1)) {
    tileMap[x][y-1] = exp1 | result;
	changes++;
  }
  if (isValid(x + 1, y - 1)) {
    tileMap[x+1][y - 1] = exp1 | result;
	changes++;
  }
  if (isValid(x + 1, y)) {
    tileMap[x+1][y] = exp1 | result;
	changes++;
  }
  if (isValid(x + 1, y + 1)) {
    tileMap[x+1][y+1] = exp1 | result;
	changes++;
  }
  if (isValid(x , y + 1)) {
    tileMap[x][y+1] = exp1 | result;
	changes++;
  }
  if (isValid(x - 1, y + 1)) {
    tileMap[x-1][y+1] = exp1 | result;
	changes++;
  }
 
  if ((result >> 4) == jem) {			//Did a monster explode into JEMS?
	  gemsTotal += changes;				//Increment the total # of gems in the stage by the change #
  }
 
 tone(900, 500, 9, 3);				

}

int isValid(uint8_t x, uint8_t y) {

	//Check here for hero man death by explosion

	uint8_t temp = tileMap[x][y];

	if (temp == man) {					//Hero caught in explosion? Time to DIE
		killGuy();
	}

	if (temp != wall && temp != door) {		//Blow up everything but walls (this includes the outer map walls) and exit door
		return 1;
	}

	return 0;
 
}

int radialCheck(uint8_t x, uint8_t y, uint8_t lookFor) {       //Checks if indicated tile appears next to current tile

	if (tileMap[x-1][y] == lookFor) {
		return 1;
	}
	if (tileMap[x][y-1] == lookFor) {
		return 1;
	}
	if (tileMap[x+1][y] == lookFor) {
		return 1;
	}	
	if (tileMap[x][y+1] == lookFor) {
		return 1;
	}	

	return 0;

}

void canSlimeGrow(uint8_t x, uint8_t y) {		//See if any cells above, below or to the side of slime are empty for growth

	//Get the pointers of tiles around slime
	ringPt[0] = &tileMap[x-1][y];
	ringPt[1] = &tileMap[x][y-1];
	ringPt[2] = &tileMap[x+1][y];
	ringPt[3] = &tileMap[x][y+1];

	int count = 0;

	++slimeTimer;
		
	for (int x = 0 ; x < 4 ; x++) {					//Check all 4 cardinal directions
	
		if (*ringPt[x] < 2) {						//Cell empty or dirt? Slime can expand into it
			if (slimeTimer >= slimeGrow) {		//Must evaluate X number of slime tiles before they can grow
				slimeTimer = 0;
				if ((++slimeExpand & 0x03) == x) {				//Also the rolling space counter must match current tile
					*ringPt[x] = slime;
					return;										//Slime can only expand 1 cell at a time
				}
			}
				
		}
	}

}

int canGasGrow(uint8_t x, uint8_t y) {		//See if any cells above, below or to the side of slime are empty for growth

	//Get the pointers of tiles around slime, bottom, left, top and right
	ringPt[0] = &tileMap[x][y + 1];
	ringPt[1] = &tileMap[x - 1][y];
	ringPt[2] = &tileMap[x][y - 1];
	ringPt[3] = &tileMap[x + 1][y];
	
	for (int x = 0 ; x < 4 ; x++) {					//Check all 4 cardinal directions
	
		if (*ringPt[x] == 0) {						//Cell empty? Gas can expand into it
			*ringPt[x] = gas;
			tone(150, 15, 1, -1);
			if (x > 1) {							//Expanded to top or right?
				*ringPt[x] |= dontMove;				//Flag bit so this won't expand again on the next row/column scan
			}		
		}
		
		if ((*ringPt[x] & 0x0F) == exp3) {		//Spread explosion on frame 3 so it's not instantaneous going right
			tileMap[scanX][scanY] = exp1;		//Explosion epicenter
			explosion(scanX, scanY, 0);
			score += 10;
		}
	}

}

void showXY() {

  Serial.print("X=");
  Serial.print(winX);
  Serial.write(9);
  Serial.print("Y=");
  Serial.println(winY);
    
}

void scrollTiles(uint8_t howManyRows) {

  uint8_t winYFineINV = 8 - winYFine;				//Get remainder of Y fine scrolling to OR in next line of pixels                        
  uint8_t courseY = winY;                           //Get the course Y value for top line of visible screen

  for (uint8_t row = 0 ; row < howManyRows ; row++) {               //Draw the 8 tile row high display

    uint8_t finePointer = winXFine;         //Copy the fine scrolling amount so we can use it as a byte pointer when scanning in graphics
    uint8_t courseX = winX;            //Find the current coarseX position for this line

    for (uint8_t colB = 0 ; colB < 128 ; colB++) {         //Draw 16 column wide display (8 pixels / 1 char at a time)

      uint8_t upper = tiles[((tileMap[courseX][courseY] & 0x0F) << 3) + finePointer] >> winYFine;
      uint8_t lower = tiles[((tileMap[courseX][courseY + 1] & 0x0F) << 3) + finePointer] << winYFineINV;

      SPDR = upper | lower;                             //Send data to SPI and increment pointer 
      if (++finePointer > 7) {                          //Done drawing this tile?
        finePointer = 0;                                //Reset fine scroll
        courseX++;                                      //...and advance course scroll by 1 byte (1 tile)
      }            
  
    }

    courseY++;                                            //Increment coarse pointer to next row
    
  }

}

void sendTiles(uint8_t howManyRows) {

  uint16_t courseY = winY;                           //Get the course Y value for top line of visible screen

  for (uint8_t row = 0 ; row < howManyRows ; row++) {               //Draw the requested number of rows

    uint8_t courseX = winX;            //Find the current coarseX position for this line

    for (uint8_t colB = 0 ; colB < 16 ; colB++) {         //Draw 16 column wide display (8 pixels / 1 char at a time)

      //getTilePointer(courseX++, courseY);                  //Get the pointer for the next tile and stuff it in cP. Increment coarseX

	  uint8_t thisTile = tileMap[courseX][courseY];					//Get the tile value
	  
	  if (thisTile < 16) {									//Use tile graphics in RAM?
		  cP = &tiles[thisTile << 3];  						//Get the pointer to the first byte of this tile   

		  for (uint8_t col = 0 ; col < 8 ; col++) {           //Send the 8 horizontal lines to the OLED
			SPDR = *cP++;                                     //Send data and increment pointer 
			delayMicroseconds(2);               
		  }		  		  
	  }
	  else {												//Else use font from flash
	
		thisTile -= 32;										//Zero-offset to 32 in ASCII

		for (uint8_t col = 0 ; col < 8 ; col++) {           //Send the 8 horizontal lines to the OLED
			SPDR = pgm_read_byte_near(font + (thisTile << 3) + col);   //Get BG tile
			delayMicroseconds(2);               
		}	

		  
	  }
	  
	  courseX++;
  
    }

    courseY++;                                            //Increment coarse pointer to next row
    
  }

}

void drawTitle() {

	for (int x = 0 ; x < 512 ; x++) {
	
		SPDR = pgm_read_byte_near(title + x);   //Get BG tile
		delayMicroseconds(2);  		
	
	}
	
}

void resetAnimation() {

	for (int x = 0 ; x < 56 ; x++) {				//Copy 40 bytes from flash pointer to tile RAM
		tiles[48 + x] = pgm_read_byte_near(aniTiles + x);
	}
	
}	

void sendMenuLine() {
	
    for (uint8_t colB = 0 ; colB < 16 ; colB++) {         //Draw 16 column wide display (8 pixels / 1 char at a time)

	  uint8_t thisTile = scratch[colB];					//Get the tile value
	  
	  if (thisTile < 16) {									//Use tile graphics in RAM?
		  cP = &tiles[thisTile << 3];  						//Get the pointer to the first byte of this tile   

		  for (uint8_t col = 0 ; col < 8 ; col++) {           //Send the 8 horizontal lines to the OLED
			SPDR = *cP++;                                     //Send data and increment pointer 
			delayMicroseconds(2);               
		  }		  		  
	  }
	  else {												//Else use font from flash
	
		thisTile -= 32;										//Zero-offset to 32 in ASCII

		for (uint8_t col = 0 ; col < 8 ; col++) {           //Send the 8 horizontal lines to the OLED
			SPDR = pgm_read_byte_near(font + (thisTile << 3) + col);   //Get BG tile
			delayMicroseconds(2);               
		}	

		  
	  }
	  
    }	
	
}

void clrScratch() {

	memset(scratch, 0, 16);	
	
}	

void text(uint8_t xPos, uint8_t yPos, const char *str) {

  while (*str) {
    tileMap[xPos++][yPos] = *str++; 
  }

}

void textMenu(uint8_t xPos, const char *str) {

  while (*str) {
    scratch[xPos++] = *str++; 
  }

}

void drawNumberMenu(uint32_t theValue, int x) {
 
  int numerals = x;           				//Always going to be at least 1 numeral
  int zPad = 0;             				//Flag for zero padding 
  unsigned long divider = 1000000000;    	//Divider starts at 1B
    
  for (int xx = 0 ; xx < 10 ; xx++) {    	//6 digit number    
    if (theValue >= divider) {
      scratch[numerals++] = '0' + (theValue / divider);
      theValue %= divider;
      zPad = 1;
      //numerals += 1;
    }   
    else if (zPad or divider == 1) {
      scratch[numerals++] = '0';
      //numerals += 1;
    } 
    divider /= 10;            
  }
  
  cursorX = numerals;						//Record cursor position

  //scratch[numerals] = 0;  
   
}

void drawNumberMap(uint32_t theValue, int x, int y) {
  
  int numerals = x;           				//Always going to be at least 1 numeral
  int zPad = 0;             				//Flag for zero padding 
  unsigned long divider = 1000000000;    	//Divider starts at 1B
    
  for (int xx = 0 ; xx < 10 ; xx++) {    	//6 digit number    
    if (theValue >= divider) {
		tileMap[x++][y] = '0' + (theValue / divider);
      theValue %= divider;
      zPad = 1;
      //numerals += 1;
    }   
    else if (zPad or divider == 1) {
		
      tileMap[x++][y] = '0';
      //numerals += 1;
    } 
    divider /= 10;            
  }

  //scratch[numerals] = 0;  
   
}

int cpuLoad() {
  return lastFrameDurationMs*100 / eachFrameMillis;
} 

bool nextFrame() {
  unsigned long now = millis();
  bool tooSoonForNextFrame = now < nextFrameStart;

  if (justRendered) {
    lastFrameDurationMs = now - lastFrameStart;
    justRendered = false;
    return false;
  }
  else if (tooSoonForNextFrame) {
    // if we have MORE than 1ms to spare (hence our comparison with 2),
    // lets sleep for power savings.  We don't compare against 1 to avoid
    // potential rounding errors - say we're actually 0.5 ms away, but a 1
    // is returned if we go to sleep we might sleep a full 1ms and then
    // we'd be running the frame slighly late.  So the last 1ms we stay
    // awake for perfect timing.

    // This is likely trading power savings for absolute timing precision
    // and the power savings might be the better goal. At 60 FPS trusting
    // chance here might actually achieve a "truer" 60 FPS than the 16ms
    // frame duration we get due to integer math.

    // We should be woken up by timer0 every 1ms, so it's ok to sleep.
    //if ((uint8_t)(nextFrameStart - now) >= 2)
     // a.idle();

    return false;
  }

  // pre-render
  justRendered = true;
  lastFrameStart = now;
  nextFrameStart = now + eachFrameMillis;
  frameCount++;

  return true;
}

bool pressed(uint8_t buttons) {
  return (a.buttonsState() & buttons) == buttons;
}

uint8_t buttonsState() {
  
  uint8_t buttons;

  // using ports here is ~100 bytes smaller than digitalRead()
#ifdef AB_DEVKIT
  // down, left, up
  buttons = ((~PINB) & B01110000);
  // right button
  buttons = buttons | (((~PINC) & B01000000) >> 4);
  // A and B
  buttons = buttons | (((~PINF) & B11000000) >> 6);
#elif defined(ARDUBOY_10)
  // down, up, left right
  buttons = ((~PINF) & B11110000);
  // A (left)
  buttons = buttons | (((~PINE) & B01000000) >> 3);
  // B (right)
  buttons = buttons | (((~PINB) & B00010000) >> 2);
#endif

  return buttons;
}

void walls() {			//Fills the map with standard walls and dirt

  for (int i = 0 ; i < 48 ; i++) {
    tileMap[i][0] = wall;
    tileMap[i][31] = wall;
  }
  for (int i = 1 ; i < 31 ; i++) {
    tileMap[0][i] = wall;
    for (int ii = 1 ; ii < 47 ; ii++) {
      tileMap[ii][i] = 1; //Fill with dirt
    }
    tileMap[47][i] = wall;
  }
 
	//Place standard door and man
	manStartX = 1;
	manStartY = 1;
	
	tileMap[1][1] = man;

	doorX = 46;
	doorY = 30;
		
	tileMap[46][30] = door;
  
	
}

void fill(uint8_t withWhat) {

	cP = &tileMap[0][0];
	
	for (g = 0 ; g < 1536 ; g++) {
		*cP++ = withWhat;
	}
	
}

ISR(TIMER0_COMPA_vect) {	// Interrupt is called once a millisecond 

	if (toneTimer) {
		
		if (toneDir) {
			//TCA0.SINGLE.CMP0 += toneDir;
			tonePitch += toneDir;		
			TC4H = highByte(tonePitch); // load the count (10 bits),
			OCR4C = lowByte(tonePitch); //  which determines the frequency		
		}		
		
		if (--toneTimer == 0) {
			TCCR4A = 0; // set normal mode (which disconnects the pin)
			tonePriority = 0;						//Priority set to 0 (anything can now play)
		}
	}	
	
}
